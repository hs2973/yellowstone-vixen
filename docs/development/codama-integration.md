# Codama Integration

This guide explains how to use Codama to automatically generate Yellowstone Vixen parsers from Solana program IDLs, streamlining the parser development process.

## What is Codama?

Codama is a powerful code generation tool that can automatically create Rust SDKs and parser implementations from Solana program Interface Definition Language (IDL) files. It eliminates the need to manually write parsing logic for complex program instructions and accounts.

## Prerequisites

### System Requirements

- **Node.js** 16+ and npm/pnpm
- **Rust** nightly-2024-02-01 or later
- **Anchor IDL** or custom IDL file for your Solana program

### Installation

```bash
# Install Codama CLI globally
npm install -g @codama/cli

# Or use with npx
npx @codama/cli --help

# For parser generation, install the Vixen renderer
npm install @codama/renderers-vixen-parser
```

## Quick Start

### 1. Prepare Your IDL

First, obtain the IDL for the program you want to parse:

```bash
# For Anchor programs
anchor idl fetch <PROGRAM_ID> --outfile program.idl

# Or create a custom IDL
# program.idl
{
  "version": "0.1.0",
  "name": "my_program",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "MyAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "authority",
            "type": "publicKey"
          },
          {
            "name": "amount",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

### 2. Generate Parser

Create a generation script:

```javascript
// codama.cjs
const path = require('node:path');
const { rootNodeFromAnchor } = require('@codama/nodes-from-anchor');
const { renderVixenParsers } = require('@codama/renderers-vixen-parser');
const { readJson } = require('@codama/renderers-core');

async function generateParser() {
    // Load IDL
    const idl = readJson('./program.idl');

    // Create root node from IDL
    const rootNode = rootNodeFromAnchor(idl);

    // Generate Vixen parser
    const output = renderVixenParsers(rootNode, {
        name: 'MyProgramParser',
        crateName: 'my-program-parser',
    });

    // Write generated code
    require('fs').writeFileSync('./src/generated.rs', output);
    console.log('Parser generated successfully!');
}

generateParser().catch(console.error);
```

Run the generation:

```bash
node codama.cjs
```

### 3. Use Generated Parser

The generated parser can be used immediately:

```rust
use my_program_parser::generated::MyProgramParser;
use yellowstone_vixen::Pipeline;

// Create pipeline with generated parser
let pipeline = Pipeline::new(
    MyProgramParser,
    [Logger, DatabaseHandler::new()]
);
```

## Advanced Configuration

### Custom Generation Options

```javascript
const output = renderVixenParsers(rootNode, {
    // Parser configuration
    name: 'CustomParser',
    crateName: 'custom-parser',

    // Import configuration
    imports: {
        customTypes: ['MyCustomType'],
        externalCrates: ['my_custom_crate'],
    },

    // Code generation options
    options: {
        deriveDebug: true,
        deriveClone: true,
        generateTests: true,
        includeComments: true,
    },

    // Error handling
    errorHandling: {
        customErrors: true,
        errorType: 'CustomError',
    }
});
```

### Handling Custom Types

For programs with custom types, extend the generation:

```javascript
// codama.cjs
const { structTypeNode, publicKeyTypeNode } = require('@codama/nodes');

// Define custom types
const customTypes = {
    'MyCustomType': structTypeNode([
        {
            name: 'field1',
            type: publicKeyTypeNode(),
        },
        {
            name: 'field2',
            type: { kind: 'string' },
        }
    ])
};

// Add to root node
const rootNode = rootNodeFromAnchor(idl);
rootNode.types = { ...rootNode.types, ...customTypes };
```

## Project Structure

### Setting Up Parser Crate

Create a proper Rust crate structure:

```bash
# Create crate
cargo new --lib my-program-parser

# Directory structure
my-program-parser/
├── src/
│   ├── lib.rs
│   ├── generated.rs  # Generated by Codama
│   └── custom.rs     # Custom logic
├── Cargo.toml
├── program.idl
└── codama.cjs
```

### Cargo.toml Configuration

```toml
[package]
name = "my-program-parser"
version = "0.1.0"
edition = "2021"

[dependencies]
yellowstone-vixen-core = "0.4"
borsh = "0.10"
solana-program = "1.16"
# Add other dependencies as needed

[build-dependencies]
# If you need build-time generation
```

### Library Structure

```rust
// src/lib.rs
pub mod generated;
pub mod custom;

// Re-export main parser
pub use generated::MyProgramParser;

// Optional: Custom wrapper
pub mod parser {
    use super::*;
    use yellowstone_vixen_core::*;

    pub struct ExtendedParser {
        base: MyProgramParser,
        // Add custom fields
    }

    impl InstructionParser for ExtendedParser {
        type Instruction = MyInstruction;
        type Error = ParseError;

        fn parse(&self, instruction: &Instruction) -> Result<Self::Instruction, Self::Error> {
            // Custom pre-processing
            self.validate_instruction(instruction)?;

            // Use generated parser
            let result = self.base.parse(instruction)?;

            // Custom post-processing
            self.enrich_instruction(result)
        }
    }
}
```

## Handling Complex Programs

### Multi-Instruction Programs

For programs with many instructions, organize the generated code:

```javascript
// Generate separate files for different instruction groups
const instructionGroups = {
    'transfers': ['transfer', 'transferChecked'],
    'accounts': ['initializeAccount', 'closeAccount'],
    'admin': ['setAuthority', 'freezeAccount']
};

Object.entries(instructionGroups).forEach(([group, instructions]) => {
    const filteredIdl = filterIdlByInstructions(idl, instructions);
    const output = renderVixenParsers(rootNodeFromAnchor(filteredIdl), {
        name: `${group}Parser`,
        crateName: `my-program-${group}`,
    });

    fs.writeFileSync(`./src/${group}.rs`, output);
});
```

### Account State Parsing

Handle complex account structures:

```rust
// In your custom wrapper
impl AccountParser for ExtendedParser {
    type Account = MyAccount;
    type Error = ParseError;

    fn parse(&self, account_info: &AccountInfo) -> Result<Self::Account, Self::Error> {
        // Use generated parser for basic parsing
        let mut account = self.base.parse(account_info)?;

        // Add custom validation
        self.validate_account(&account)?;

        // Enrich with additional data
        account.enriched_field = self.compute_enriched_field(&account);

        Ok(account)
    }
}
```

## Error Handling

### Custom Error Types

```rust
// In generated.rs (customize via Codama options)
#[derive(Debug, thiserror::Error)]
pub enum ParserError {
    #[error("IDL parsing error: {0}")]
    IdlParsing(String),

    #[error("Instruction parsing error: {0}")]
    InstructionParsing(String),

    #[error("Account parsing error: {0}")]
    AccountParsing(String),

    #[error("Validation error: {0}")]
    Validation(String),
}
```

### Error Recovery

```rust
impl ExtendedParser {
    fn parse_with_recovery(&self, instruction: &Instruction) -> Result<MyInstruction, ParserError> {
        match self.parse(instruction) {
            Ok(result) => Ok(result),
            Err(ParserError::Validation(_)) => {
                // Log but don't fail
                tracing::warn!("Validation failed for instruction: {:?}", instruction);
                Err(ParserError::Filtered)
            }
            Err(e) => Err(e),
        }
    }
}
```

## Testing Generated Parsers

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use yellowstone_vixen_core::test_utils::*;

    #[test]
    fn test_generated_parser() {
        let parser = MyProgramParser;

        // Test with valid instruction
        let instruction = create_test_instruction("initialize", InitializeArgs {
            amount: 1000,
        });

        let result = parser.parse(&instruction);
        assert!(result.is_ok());
    }

    #[test]
    fn test_custom_validation() {
        let parser = ExtendedParser::new();

        // Test custom validation logic
        let account = create_test_account();
        let result = parser.parse(&account);

        // Verify custom enrichments
        if let Ok(parsed) = result {
            assert!(parsed.enriched_field.is_some());
        }
    }
}
```

### Integration Tests

```rust
#[cfg(test)]
mod integration_tests {
    use yellowstone_vixen_mock::*;
    use super::*;

    #[tokio::test]
    async fn test_with_real_data() {
        // Load real program data
        let fixtures = FixtureLoader::new("./fixtures")
            .load_from_chain("MyProgram111111111111111111111111111")
            .build();

        let mock_env = MockEnvironment::new(fixtures);
        let parser = MyProgramParser;

        let results = mock_env.run_parser(parser).await;

        // Verify parsing works with real data
        assert!(!results.is_empty());
        for result in results {
            assert!(result.is_ok());
        }
    }
}
```

## Performance Optimization

### Generated Code Optimization

```javascript
// Optimize generation for performance
const output = renderVixenParsers(rootNode, {
    options: {
        // Generate more efficient code
        optimizeParsing: true,
        inlineSmallFunctions: true,

        // Reduce allocations
        reuseBuffers: true,
        avoidCloning: true,
    }
});
```

### Custom Performance Improvements

```rust
impl FastParser {
    // Pre-compile discriminators
    const DISCRIMINATORS: phf::Map<&'static str, u64> = phf::phf_map! {
        "initialize" => 0x12345678abcdef12u64,
        "transfer" => 0x87654321fedcba21u64,
    };

    pub fn fast_discriminator_lookup(&self, name: &str) -> Option<u64> {
        Self::DISCRIMINATORS.get(name).copied()
    }
}
```

## Maintenance and Updates

### Updating Generated Code

```bash
# When IDL changes, regenerate
node codama.cjs

# Review changes
git diff src/generated.rs

# Test updated code
cargo test
```

### Handling IDL Changes

```rust
// In your custom wrapper, handle version differences
impl VersionAwareParser {
    fn parse_with_version(&self, instruction: &Instruction, version: u32) -> Result<MyInstruction, ParserError> {
        match version {
            1 => self.parse_v1(instruction),
            2 => self.parse_v2(instruction),
            _ => Err(ParserError::UnsupportedVersion(version)),
        }
    }
}
```

## Best Practices

### Code Generation

1. **Version Control** - Commit generated code for reproducibility
2. **Review Changes** - Always review generated code changes
3. **Test Thoroughly** - Generated code needs comprehensive testing
4. **Document Overrides** - Document any custom modifications

### Parser Development

1. **Start with Generation** - Use Codama for initial implementation
2. **Add Custom Logic** - Extend with custom validation and enrichment
3. **Maintain Compatibility** - Ensure updates don't break existing functionality
4. **Performance First** - Optimize generated code for your use case

### Project Organization

1. **Separate Generated Code** - Keep generated and custom code separate
2. **Clear Module Structure** - Organize code into logical modules
3. **Comprehensive Tests** - Test both generated and custom functionality
4. **Documentation** - Document custom extensions and modifications

## Troubleshooting

### Common Issues

**IDL Parsing Errors:**
```javascript
// Add error handling to generation script
try {
    const idl = readJson('./program.idl');
    // ... generation logic
} catch (error) {
    console.error('Failed to parse IDL:', error.message);
    process.exit(1);
}
```

**Type Resolution Issues:**
```javascript
// Ensure all types are properly defined
const rootNode = rootNodeFromAnchor(idl);

// Add missing type definitions
rootNode.types = {
    ...rootNode.types,
    'MissingType': structTypeNode([...])
};
```

**Performance Issues:**
```rust
// Profile generated code
#[cfg(feature = "profiling")]
impl ProfiledParser {
    pub fn parse_with_profiling(&self, instruction: &Instruction) -> Result<MyInstruction, ParserError> {
        let start = std::time::Instant::now();
        let result = self.parse(instruction);
        let duration = start.elapsed();

        tracing::info!("Parsing took {:?}", duration);
        result
    }
}
```

## Examples

### Complete Examples

See the `crates/` directory for real parser implementations using Codama:

- **Jupiter Swap Parser** - `crates/jupiter-swap-parser/`
- **Meteora Parser** - `crates/meteora-parser/`
- **Raydium Parser** - `crates/raydium-amm-v4-parser/`

### Example Generation Script

```javascript
// examples/codama-generation/codama.cjs
const fs = require('fs');
const path = require('path');
const { rootNodeFromAnchor } = require('@codama/nodes-from-anchor');
const { renderVixenParsers } = require('@codama/renderers-vixen-parser');
const { readJson } = require('@codama/renderers-core');

async function generateExampleParser() {
    // Load example IDL
    const idlPath = path.join(__dirname, 'example-program.idl');
    const idl = readJson(idlPath);

    // Generate parser
    const rootNode = rootNodeFromAnchor(idl);
    const output = renderVixenParsers(rootNode, {
        name: 'ExampleProgramParser',
        crateName: 'example-program-parser',
        options: {
            generateTests: true,
            includeComments: true,
        }
    });

    // Write output
    const outputPath = path.join(__dirname, 'src', 'generated.rs');
    fs.writeFileSync(outputPath, output);

    console.log('Example parser generated at:', outputPath);
}

generateExampleParser().catch(console.error);
```

This comprehensive guide shows how Codama can significantly accelerate parser development while maintaining high code quality and performance.
