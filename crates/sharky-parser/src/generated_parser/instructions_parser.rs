//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CloseNftList as CloseNftListIxAccounts, CloseOrderBook as CloseOrderBookIxAccounts,
        CreateNftList as CreateNftListIxAccounts,
        CreateNftListInstructionArgs as CreateNftListIxData,
        CreateOrderBook as CreateOrderBookIxAccounts,
        CreateOrderBookInstructionArgs as CreateOrderBookIxData,
        CreateProgramVersion as CreateProgramVersionIxAccounts,
        CreateProgramVersionInstructionArgs as CreateProgramVersionIxData,
        ExtendLoanV3 as ExtendLoanV3IxAccounts,
        ExtendLoanV3Compressed as ExtendLoanV3CompressedIxAccounts,
        ExtendLoanV3CompressedInstructionArgs as ExtendLoanV3CompressedIxData,
        ExtendLoanV3InstructionArgs as ExtendLoanV3IxData,
        ForecloseLoanV3 as ForecloseLoanV3IxAccounts,
        ForecloseLoanV3Compressed as ForecloseLoanV3CompressedIxAccounts,
        ForecloseLoanV3CompressedInstructionArgs as ForecloseLoanV3CompressedIxData,
        OfferLoan as OfferLoanIxAccounts, OfferLoanInstructionArgs as OfferLoanIxData,
        RepayLoanV3 as RepayLoanV3IxAccounts,
        RepayLoanV3Compressed as RepayLoanV3CompressedIxAccounts,
        RepayLoanV3CompressedInstructionArgs as RepayLoanV3CompressedIxData,
        RescindLoan as RescindLoanIxAccounts, TakeLoanV3 as TakeLoanV3IxAccounts,
        TakeLoanV3Compressed as TakeLoanV3CompressedIxAccounts,
        TakeLoanV3CompressedInstructionArgs as TakeLoanV3CompressedIxData,
        TakeLoanV3InstructionArgs as TakeLoanV3IxData, UpdateNftList as UpdateNftListIxAccounts,
        UpdateNftListInstructionArgs as UpdateNftListIxData,
        UpdateOrderBook as UpdateOrderBookIxAccounts,
        UpdateOrderBookInstructionArgs as UpdateOrderBookIxData,
        UpdateProgramVersion as UpdateProgramVersionIxAccounts,
        UpdateProgramVersionInstructionArgs as UpdateProgramVersionIxData,
    },
    ID,
};

/// Sharky Instructions
#[derive(Debug)]
pub enum SharkyProgramIx {
    CreateOrderBook(CreateOrderBookIxAccounts, CreateOrderBookIxData),
    UpdateOrderBook(UpdateOrderBookIxAccounts, UpdateOrderBookIxData),
    CloseOrderBook(CloseOrderBookIxAccounts),
    OfferLoan(OfferLoanIxAccounts, OfferLoanIxData),
    RescindLoan(RescindLoanIxAccounts),
    TakeLoanV3(TakeLoanV3IxAccounts, TakeLoanV3IxData),
    TakeLoanV3Compressed(TakeLoanV3CompressedIxAccounts, TakeLoanV3CompressedIxData),
    ForecloseLoanV3(ForecloseLoanV3IxAccounts),
    ForecloseLoanV3Compressed(
        ForecloseLoanV3CompressedIxAccounts,
        ForecloseLoanV3CompressedIxData,
    ),
    RepayLoanV3Compressed(RepayLoanV3CompressedIxAccounts, RepayLoanV3CompressedIxData),
    RepayLoanV3(RepayLoanV3IxAccounts),
    ExtendLoanV3(ExtendLoanV3IxAccounts, ExtendLoanV3IxData),
    ExtendLoanV3Compressed(
        ExtendLoanV3CompressedIxAccounts,
        ExtendLoanV3CompressedIxData,
    ),
    CreateNftList(CreateNftListIxAccounts, CreateNftListIxData),
    UpdateNftList(UpdateNftListIxAccounts, UpdateNftListIxData),
    CloseNftList(CloseNftListIxAccounts),
    CreateProgramVersion(CreateProgramVersionIxAccounts, CreateProgramVersionIxData),
    UpdateProgramVersion(UpdateProgramVersionIxAccounts, UpdateProgramVersionIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = SharkyProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Sharky::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<SharkyProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [153, 114, 9, 51, 100, 68, 240, 197] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CreateOrderBookIxAccounts {
                    order_book: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: CreateOrderBookIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::CreateOrderBook(ix_accounts, de_ix_data))
            },
            [31, 72, 159, 232, 220, 153, 90, 109] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateOrderBookIxAccounts {
                    order_book: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateOrderBookIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::UpdateOrderBook(ix_accounts, de_ix_data))
            },
            [219, 134, 73, 219, 180, 7, 94, 206] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = CloseOrderBookIxAccounts {
                    order_book: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                };
                Ok(SharkyProgramIx::CloseOrderBook(ix_accounts))
            },
            [44, 12, 76, 144, 210, 208, 239, 85] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = OfferLoanIxAccounts {
                    lender: ix.accounts[0].0.into(),
                    lender_value_token_account: ix.accounts[1].0.into(),
                    value_mint: ix.accounts[2].0.into(),
                    loan: ix.accounts[3].0.into(),
                    escrow: ix.accounts[4].0.into(),
                    escrow_token_account: ix.accounts[5].0.into(),
                    order_book: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                };
                let de_ix_data: OfferLoanIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::OfferLoan(ix_accounts, de_ix_data))
            },
            [64, 64, 160, 211, 51, 36, 177, 158] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = RescindLoanIxAccounts {
                    loan: ix.accounts[0].0.into(),
                    lender_value_token_account: ix.accounts[1].0.into(),
                    lender: ix.accounts[2].0.into(),
                    value_mint: ix.accounts[3].0.into(),
                    escrow: ix.accounts[4].0.into(),
                    escrow_token_account: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                };
                Ok(SharkyProgramIx::RescindLoan(ix_accounts))
            },
            [255, 115, 220, 58, 26, 157, 112, 185] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = TakeLoanV3IxAccounts {
                    lender: ix.accounts[0].0.into(),
                    borrower: ix.accounts[1].0.into(),
                    borrower_collateral_token_account: ix.accounts[2].0.into(),
                    collateral_mint: ix.accounts[3].0.into(),
                    loan: ix.accounts[4].0.into(),
                    escrow: ix.accounts[5].0.into(),
                    escrow_collateral_token_account: ix.accounts[6].0.into(),
                    order_book: ix.accounts[7].0.into(),
                    metadata: ix.accounts[8].0.into(),
                    edition: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    associated_token_program: ix.accounts[12].0.into(),
                    rent: ix.accounts[13].0.into(),
                    mpl_token_metadata_program: ix.accounts[14].0.into(),
                };
                let de_ix_data: TakeLoanV3IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::TakeLoanV3(ix_accounts, de_ix_data))
            },
            [241, 114, 106, 79, 16, 89, 233, 125] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = TakeLoanV3CompressedIxAccounts {
                    lender: ix.accounts[0].0.into(),
                    borrower: ix.accounts[1].0.into(),
                    loan: ix.accounts[2].0.into(),
                    escrow: ix.accounts[3].0.into(),
                    order_book: ix.accounts[4].0.into(),
                    collateral_mint: ix.accounts[5].0.into(),
                    tree_authority: ix.accounts[6].0.into(),
                    log_wrapper: ix.accounts[7].0.into(),
                    merkle_tree: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    mpl_bubblegum_program: ix.accounts[11].0.into(),
                    compression_program: ix.accounts[12].0.into(),
                    rent: ix.accounts[13].0.into(),
                };
                let de_ix_data: TakeLoanV3CompressedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::TakeLoanV3Compressed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [136, 184, 50, 58, 183, 92, 63, 216] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = ForecloseLoanV3IxAccounts {
                    loan: ix.accounts[0].0.into(),
                    escrow: ix.accounts[1].0.into(),
                    escrow_collateral_token_account: ix.accounts[2].0.into(),
                    collateral_mint: ix.accounts[3].0.into(),
                    borrower: ix.accounts[4].0.into(),
                    lender: ix.accounts[5].0.into(),
                    lender_collateral_token_account: ix.accounts[6].0.into(),
                    borrower_collateral_token_account: ix.accounts[7].0.into(),
                    metadata: ix.accounts[8].0.into(),
                    edition: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    associated_token_program: ix.accounts[12].0.into(),
                    rent: ix.accounts[13].0.into(),
                    mpl_token_metadata_program: ix.accounts[14].0.into(),
                };
                Ok(SharkyProgramIx::ForecloseLoanV3(ix_accounts))
            },
            [194, 193, 5, 193, 115, 133, 231, 197] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = ForecloseLoanV3CompressedIxAccounts {
                    loan: ix.accounts[0].0.into(),
                    escrow: ix.accounts[1].0.into(),
                    borrower: ix.accounts[2].0.into(),
                    lender: ix.accounts[3].0.into(),
                    tree_authority: ix.accounts[4].0.into(),
                    log_wrapper: ix.accounts[5].0.into(),
                    merkle_tree: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    mpl_bubblegum_program: ix.accounts[9].0.into(),
                    compression_program: ix.accounts[10].0.into(),
                    rent: ix.accounts[11].0.into(),
                };
                let de_ix_data: ForecloseLoanV3CompressedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::ForecloseLoanV3Compressed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [159, 159, 245, 168, 191, 154, 100, 6] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = RepayLoanV3CompressedIxAccounts {
                    loan: ix.accounts[0].0.into(),
                    borrower: ix.accounts[1].0.into(),
                    lender: ix.accounts[2].0.into(),
                    escrow: ix.accounts[3].0.into(),
                    value_mint: ix.accounts[4].0.into(),
                    order_book: ix.accounts[5].0.into(),
                    fee_authority: ix.accounts[6].0.into(),
                    tree_authority: ix.accounts[7].0.into(),
                    log_wrapper: ix.accounts[8].0.into(),
                    merkle_tree: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    mpl_bubblegum_program: ix.accounts[12].0.into(),
                    compression_program: ix.accounts[13].0.into(),
                    rent: ix.accounts[14].0.into(),
                };
                let de_ix_data: RepayLoanV3CompressedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::RepayLoanV3Compressed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [97, 123, 85, 54, 76, 16, 61, 157] => {
                check_min_accounts_req(accounts_len, 17)?;
                let ix_accounts = RepayLoanV3IxAccounts {
                    loan: ix.accounts[0].0.into(),
                    borrower: ix.accounts[1].0.into(),
                    borrower_collateral_token_account: ix.accounts[2].0.into(),
                    lender: ix.accounts[3].0.into(),
                    escrow: ix.accounts[4].0.into(),
                    escrow_collateral_token_account: ix.accounts[5].0.into(),
                    value_mint: ix.accounts[6].0.into(),
                    collateral_mint: ix.accounts[7].0.into(),
                    order_book: ix.accounts[8].0.into(),
                    fee_authority: ix.accounts[9].0.into(),
                    metadata: ix.accounts[10].0.into(),
                    edition: ix.accounts[11].0.into(),
                    system_program: ix.accounts[12].0.into(),
                    token_program: ix.accounts[13].0.into(),
                    associated_token_program: ix.accounts[14].0.into(),
                    rent: ix.accounts[15].0.into(),
                    mpl_token_metadata_program: ix.accounts[16].0.into(),
                };
                Ok(SharkyProgramIx::RepayLoanV3(ix_accounts))
            },
            [71, 27, 17, 131, 78, 73, 62, 92] => {
                check_min_accounts_req(accounts_len, 21)?;
                let ix_accounts = ExtendLoanV3IxAccounts {
                    loan: ix.accounts[0].0.into(),
                    new_loan: ix.accounts[1].0.into(),
                    borrower: ix.accounts[2].0.into(),
                    borrower_collateral_token_account: ix.accounts[3].0.into(),
                    lender: ix.accounts[4].0.into(),
                    new_lender: ix.accounts[5].0.into(),
                    escrow: ix.accounts[6].0.into(),
                    escrow_collateral_token_account: ix.accounts[7].0.into(),
                    new_escrow: ix.accounts[8].0.into(),
                    new_escrow_collateral_token_account: ix.accounts[9].0.into(),
                    value_mint: ix.accounts[10].0.into(),
                    collateral_mint: ix.accounts[11].0.into(),
                    order_book: ix.accounts[12].0.into(),
                    fee_authority: ix.accounts[13].0.into(),
                    metadata: ix.accounts[14].0.into(),
                    edition: ix.accounts[15].0.into(),
                    system_program: ix.accounts[16].0.into(),
                    token_program: ix.accounts[17].0.into(),
                    associated_token_program: ix.accounts[18].0.into(),
                    rent: ix.accounts[19].0.into(),
                    mpl_token_metadata_program: ix.accounts[20].0.into(),
                };
                let de_ix_data: ExtendLoanV3IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::ExtendLoanV3(ix_accounts, de_ix_data))
            },
            [148, 161, 75, 87, 138, 34, 131, 62] => {
                check_min_accounts_req(accounts_len, 18)?;
                let ix_accounts = ExtendLoanV3CompressedIxAccounts {
                    loan: ix.accounts[0].0.into(),
                    new_loan: ix.accounts[1].0.into(),
                    borrower: ix.accounts[2].0.into(),
                    lender: ix.accounts[3].0.into(),
                    new_lender: ix.accounts[4].0.into(),
                    escrow: ix.accounts[5].0.into(),
                    new_escrow: ix.accounts[6].0.into(),
                    value_mint: ix.accounts[7].0.into(),
                    order_book: ix.accounts[8].0.into(),
                    fee_authority: ix.accounts[9].0.into(),
                    tree_authority: ix.accounts[10].0.into(),
                    log_wrapper: ix.accounts[11].0.into(),
                    merkle_tree: ix.accounts[12].0.into(),
                    system_program: ix.accounts[13].0.into(),
                    token_program: ix.accounts[14].0.into(),
                    mpl_bubblegum_program: ix.accounts[15].0.into(),
                    compression_program: ix.accounts[16].0.into(),
                    rent: ix.accounts[17].0.into(),
                };
                let de_ix_data: ExtendLoanV3CompressedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::ExtendLoanV3Compressed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [243, 38, 198, 76, 172, 64, 127, 24] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = CreateNftListIxAccounts {
                    nft_list: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                };
                let de_ix_data: CreateNftListIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::CreateNftList(ix_accounts, de_ix_data))
            },
            [215, 13, 25, 187, 11, 93, 34, 143] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateNftListIxAccounts {
                    nft_list: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateNftListIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::UpdateNftList(ix_accounts, de_ix_data))
            },
            [35, 8, 121, 82, 218, 78, 252, 162] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = CloseNftListIxAccounts {
                    nft_list: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                };
                Ok(SharkyProgramIx::CloseNftList(ix_accounts))
            },
            [103, 216, 0, 238, 92, 107, 219, 121] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = CreateProgramVersionIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    program_version: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                    rent: ix.accounts[3].0.into(),
                };
                let de_ix_data: CreateProgramVersionIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::CreateProgramVersion(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [235, 132, 215, 225, 213, 43, 43, 38] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateProgramVersionIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    program_version: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateProgramVersionIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(SharkyProgramIx::UpdateProgramVersion(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
