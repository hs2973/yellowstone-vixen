//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CancelExpiredOrder as CancelExpiredOrderIxAccounts, CancelOrder as CancelOrderIxAccounts,
        FillOrder as FillOrderIxAccounts, FillOrderInstructionArgs as FillOrderIxData,
        FlashFillOrder as FlashFillOrderIxAccounts,
        FlashFillOrderInstructionArgs as FlashFillOrderIxData, InitFee as InitFeeIxAccounts,
        InitFeeInstructionArgs as InitFeeIxData, InitializeOrder as InitializeOrderIxAccounts,
        InitializeOrderInstructionArgs as InitializeOrderIxData,
        PreFlashFillOrder as PreFlashFillOrderIxAccounts,
        PreFlashFillOrderInstructionArgs as PreFlashFillOrderIxData,
        UpdateFee as UpdateFeeIxAccounts, UpdateFeeInstructionArgs as UpdateFeeIxData,
        WithdrawFee as WithdrawFeeIxAccounts, WithdrawFeeInstructionArgs as WithdrawFeeIxData,
    },
    ID,
};

/// LimitOrder Instructions
#[derive(Debug)]
pub enum LimitOrderProgramIx {
    InitializeOrder(InitializeOrderIxAccounts, InitializeOrderIxData),
    FillOrder(FillOrderIxAccounts, FillOrderIxData),
    PreFlashFillOrder(PreFlashFillOrderIxAccounts, PreFlashFillOrderIxData),
    FlashFillOrder(FlashFillOrderIxAccounts, FlashFillOrderIxData),
    CancelOrder(CancelOrderIxAccounts),
    CancelExpiredOrder(CancelExpiredOrderIxAccounts),
    WithdrawFee(WithdrawFeeIxAccounts, WithdrawFeeIxData),
    InitFee(InitFeeIxAccounts, InitFeeIxData),
    UpdateFee(UpdateFeeIxAccounts, UpdateFeeIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = LimitOrderProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "LimitOrder::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<LimitOrderProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [240, 47, 153, 68, 13, 190, 225, 42] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = PreFlashFillOrderIxAccounts {
                    order: ix.accounts[0].0.into(),
                    reserve: ix.accounts[1].0.into(),
                    taker: ix.accounts[2].0.into(),
                    taker_output_account: ix.accounts[3].0.into(),
                    input_mint: ix.accounts[4].0.into(),
                    input_mint_token_program: ix.accounts[5].0.into(),
                    instruction: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: PreFlashFillOrderIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrderProgramIx::PreFlashFillOrder(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [14, 122, 231, 218, 31, 238, 223, 150] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = WithdrawFeeIxAccounts {
                    admin: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                    program_fee_account: ix.accounts[2].0.into(),
                    admin_token_acocunt: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    mint: ix.accounts[5].0.into(),
                };
                let de_ix_data: WithdrawFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrderProgramIx::WithdrawFee(ix_accounts, de_ix_data))
            },
            [13, 9, 211, 107, 62, 172, 224, 67] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = InitFeeIxAccounts {
                    keeper: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: InitFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrderProgramIx::InitFee(ix_accounts, de_ix_data))
            },
            [232, 253, 195, 247, 148, 212, 73, 222] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateFeeIxAccounts {
                    keeper: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrderProgramIx::UpdateFee(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
