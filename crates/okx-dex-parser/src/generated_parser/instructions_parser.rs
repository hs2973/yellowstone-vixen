//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CommissionSolFromSwap as CommissionSolFromSwapIxAccounts,
        CommissionSolFromSwapInstructionArgs as CommissionSolFromSwapIxData,
        CommissionSolProxySwap as CommissionSolProxySwapIxAccounts,
        CommissionSolProxySwapInstructionArgs as CommissionSolProxySwapIxData,
        CommissionSolSwap as CommissionSolSwapIxAccounts,
        CommissionSolSwap2 as CommissionSolSwap2IxAccounts,
        CommissionSolSwap2InstructionArgs as CommissionSolSwap2IxData,
        CommissionSolSwapInstructionArgs as CommissionSolSwapIxData,
        CommissionSplFromSwap as CommissionSplFromSwapIxAccounts,
        CommissionSplFromSwapInstructionArgs as CommissionSplFromSwapIxData,
        CommissionSplProxySwap as CommissionSplProxySwapIxAccounts,
        CommissionSplProxySwapInstructionArgs as CommissionSplProxySwapIxData,
        CommissionSplSwap as CommissionSplSwapIxAccounts,
        CommissionSplSwap2 as CommissionSplSwap2IxAccounts,
        CommissionSplSwap2InstructionArgs as CommissionSplSwap2IxData,
        CommissionSplSwapInstructionArgs as CommissionSplSwapIxData,
        FromSwapLog as FromSwapLogIxAccounts, FromSwapLogInstructionArgs as FromSwapLogIxData,
        ProxySwap as ProxySwapIxAccounts, ProxySwapInstructionArgs as ProxySwapIxData,
        Swap as SwapIxAccounts, Swap2 as Swap2IxAccounts, Swap2InstructionArgs as Swap2IxData,
        SwapInstructionArgs as SwapIxData,
    },
    ID,
};

/// DexSolana Instructions
#[derive(Debug)]
pub enum DexSolanaProgramIx {
    CommissionSolFromSwap(CommissionSolFromSwapIxAccounts, CommissionSolFromSwapIxData),
    CommissionSolProxySwap(
        CommissionSolProxySwapIxAccounts,
        CommissionSolProxySwapIxData,
    ),
    CommissionSolSwap(CommissionSolSwapIxAccounts, CommissionSolSwapIxData),
    CommissionSolSwap2(CommissionSolSwap2IxAccounts, CommissionSolSwap2IxData),
    CommissionSplFromSwap(CommissionSplFromSwapIxAccounts, CommissionSplFromSwapIxData),
    CommissionSplProxySwap(
        CommissionSplProxySwapIxAccounts,
        CommissionSplProxySwapIxData,
    ),
    CommissionSplSwap(CommissionSplSwapIxAccounts, CommissionSplSwapIxData),
    CommissionSplSwap2(CommissionSplSwap2IxAccounts, CommissionSplSwap2IxData),
    FromSwapLog(FromSwapLogIxAccounts, FromSwapLogIxData),
    ProxySwap(ProxySwapIxAccounts, ProxySwapIxData),
    Swap(SwapIxAccounts, SwapIxData),
    Swap2(Swap2IxAccounts, Swap2IxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = DexSolanaProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "DexSolana::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<DexSolanaProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [129, 59, 69, 10, 132, 76, 35, 20] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = CommissionSolFromSwapIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    bridge_program: ix.accounts[5].0.into(),
                    associated_token_program: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    token2022_program: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    commission_account: ix.accounts[10].0.into(),
                };
                let de_ix_data: CommissionSolFromSwapIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::CommissionSolFromSwap(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [81, 128, 134, 73, 114, 73, 45, 94] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CommissionSolSwapIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    commission_account: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: CommissionSolSwapIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::CommissionSolSwap(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [113, 132, 31, 74, 99, 169, 57, 146] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CommissionSolSwap2IxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    commission_account: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: CommissionSolSwap2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::CommissionSolSwap2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [5, 77, 144, 50, 222, 228, 233, 171] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = CommissionSplFromSwapIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    bridge_program: ix.accounts[5].0.into(),
                    associated_token_program: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    token2022_program: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    commission_token_account: ix.accounts[10].0.into(),
                };
                let de_ix_data: CommissionSplFromSwapIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::CommissionSplFromSwap(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [235, 71, 211, 196, 114, 199, 143, 92] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CommissionSplSwapIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    commission_token_account: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: CommissionSplSwapIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::CommissionSplSwap(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [173, 131, 78, 38, 150, 165, 123, 15] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CommissionSplSwap2IxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    commission_token_account: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: CommissionSplSwap2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::CommissionSplSwap2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [133, 186, 15, 105, 31, 76, 31, 112] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = FromSwapLogIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                    bridge_program: ix.accounts[5].0.into(),
                    associated_token_program: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    token2022_program: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                };
                let de_ix_data: FromSwapLogIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::FromSwapLog(ix_accounts, de_ix_data))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = SwapIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                };
                let de_ix_data: SwapIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::Swap(ix_accounts, de_ix_data))
            },
            [65, 75, 63, 76, 235, 91, 91, 136] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = Swap2IxAccounts {
                    payer: ix.accounts[0].0.into(),
                    source_token_account: ix.accounts[1].0.into(),
                    destination_token_account: ix.accounts[2].0.into(),
                    source_mint: ix.accounts[3].0.into(),
                    destination_mint: ix.accounts[4].0.into(),
                };
                let de_ix_data: Swap2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DexSolanaProgramIx::Swap2(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
