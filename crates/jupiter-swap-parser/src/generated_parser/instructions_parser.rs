//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        Claim as ClaimIxAccounts, ClaimInstructionArgs as ClaimIxData,
        ClaimToken as ClaimTokenIxAccounts, ClaimTokenInstructionArgs as ClaimTokenIxData,
        CloseToken as CloseTokenIxAccounts, CloseTokenInstructionArgs as CloseTokenIxData,
        CreateOpenOrders as CreateOpenOrdersIxAccounts,
        CreateProgramOpenOrders as CreateProgramOpenOrdersIxAccounts,
        CreateProgramOpenOrdersInstructionArgs as CreateProgramOpenOrdersIxData,
        CreateTokenAccount as CreateTokenAccountIxAccounts,
        CreateTokenAccountInstructionArgs as CreateTokenAccountIxData,
        CreateTokenLedger as CreateTokenLedgerIxAccounts, ExactOutRoute as ExactOutRouteIxAccounts,
        ExactOutRouteInstructionArgs as ExactOutRouteIxData, Route as RouteIxAccounts,
        RouteInstructionArgs as RouteIxData,
        RouteWithTokenLedger as RouteWithTokenLedgerIxAccounts,
        RouteWithTokenLedgerInstructionArgs as RouteWithTokenLedgerIxData,
        SetTokenLedger as SetTokenLedgerIxAccounts,
        SharedAccountsExactOutRoute as SharedAccountsExactOutRouteIxAccounts,
        SharedAccountsExactOutRouteInstructionArgs as SharedAccountsExactOutRouteIxData,
        SharedAccountsRoute as SharedAccountsRouteIxAccounts,
        SharedAccountsRouteInstructionArgs as SharedAccountsRouteIxData,
        SharedAccountsRouteWithTokenLedger as SharedAccountsRouteWithTokenLedgerIxAccounts,
        SharedAccountsRouteWithTokenLedgerInstructionArgs as SharedAccountsRouteWithTokenLedgerIxData,
    },
    ID,
};

/// Jupiter Instructions
#[derive(Debug)]
pub enum JupiterProgramIx {
    Claim(ClaimIxAccounts, ClaimIxData),
    ClaimToken(ClaimTokenIxAccounts, ClaimTokenIxData),
    CloseToken(CloseTokenIxAccounts, CloseTokenIxData),
    CreateOpenOrders(CreateOpenOrdersIxAccounts),
    CreateProgramOpenOrders(
        CreateProgramOpenOrdersIxAccounts,
        CreateProgramOpenOrdersIxData,
    ),
    CreateTokenLedger(CreateTokenLedgerIxAccounts),
    CreateTokenAccount(CreateTokenAccountIxAccounts, CreateTokenAccountIxData),
    ExactOutRoute(ExactOutRouteIxAccounts, ExactOutRouteIxData),
    Route(RouteIxAccounts, RouteIxData),
    RouteWithTokenLedger(RouteWithTokenLedgerIxAccounts, RouteWithTokenLedgerIxData),
    SetTokenLedger(SetTokenLedgerIxAccounts),
    SharedAccountsExactOutRoute(
        SharedAccountsExactOutRouteIxAccounts,
        SharedAccountsExactOutRouteIxData,
    ),
    SharedAccountsRoute(SharedAccountsRouteIxAccounts, SharedAccountsRouteIxData),
    SharedAccountsRouteWithTokenLedger(
        SharedAccountsRouteWithTokenLedgerIxAccounts,
        SharedAccountsRouteWithTokenLedgerIxData,
    ),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = JupiterProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Jupiter::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<JupiterProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [62, 198, 214, 193, 213, 159, 108, 210] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ClaimIxAccounts {
                    wallet: ix.accounts[0].0.into(),
                    program_authority: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: ClaimIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::Claim(ix_accounts, de_ix_data))
            },
            [116, 206, 27, 191, 166, 19, 0, 73] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = ClaimTokenIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    wallet: ix.accounts[1].0.into(),
                    program_authority: ix.accounts[2].0.into(),
                    program_token_account: ix.accounts[3].0.into(),
                    destination_token_account: ix.accounts[4].0.into(),
                    mint: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    associated_token_program: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: ClaimTokenIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::ClaimToken(ix_accounts, de_ix_data))
            },
            [26, 74, 236, 151, 104, 64, 183, 249] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CloseTokenIxAccounts {
                    operator: ix.accounts[0].0.into(),
                    wallet: ix.accounts[1].0.into(),
                    program_authority: ix.accounts[2].0.into(),
                    program_token_account: ix.accounts[3].0.into(),
                    mint: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: CloseTokenIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::CloseToken(ix_accounts, de_ix_data))
            },
            [229, 194, 212, 172, 8, 10, 134, 147] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CreateOpenOrdersIxAccounts {
                    open_orders: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    dex_program: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    rent: ix.accounts[4].0.into(),
                    market: ix.accounts[5].0.into(),
                };
                Ok(JupiterProgramIx::CreateOpenOrders(ix_accounts))
            },
            [28, 226, 32, 148, 188, 136, 113, 171] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CreateProgramOpenOrdersIxAccounts {
                    open_orders: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    program_authority: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                    rent: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                };
                let de_ix_data: CreateProgramOpenOrdersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::CreateProgramOpenOrders(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [232, 242, 197, 253, 240, 143, 129, 52] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CreateTokenLedgerIxAccounts {
                    token_ledger: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                Ok(JupiterProgramIx::CreateTokenLedger(ix_accounts))
            },
            [147, 241, 123, 100, 244, 132, 174, 118] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CreateTokenAccountIxAccounts {
                    token_account: ix.accounts[0].0.into(),
                    user: ix.accounts[1].0.into(),
                    mint: ix.accounts[2].0.into(),
                    token_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: CreateTokenAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::CreateTokenAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [228, 85, 185, 112, 78, 79, 77, 2] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetTokenLedgerIxAccounts {
                    token_ledger: ix.accounts[0].0.into(),
                    token_account: ix.accounts[1].0.into(),
                };
                Ok(JupiterProgramIx::SetTokenLedger(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
