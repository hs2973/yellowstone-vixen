//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        AddMarketIndexes as AddMarketIndexesIxAccounts,
        AddPerpMarketIndex as AddPerpMarketIndexIxAccounts,
        AddPerpMarketIndexInstructionArgs as AddPerpMarketIndexIxData,
        ApplyPerpFunding as ApplyPerpFundingIxAccounts,
        ApplyPerpFundingInstructionArgs as ApplyPerpFundingIxData,
        BurnVaultTokens as BurnVaultTokensIxAccounts,
        CancelAllMarketOrders as CancelAllMarketOrdersIxAccounts,
        CancelAllMarketOrdersInstructionArgs as CancelAllMarketOrdersIxData,
        CancelOrder as CancelOrderIxAccounts,
        CancelOrderByClientOrderId as CancelOrderByClientOrderIdIxAccounts,
        CancelOrderByClientOrderIdInstructionArgs as CancelOrderByClientOrderIdIxData,
        CancelOrderByClientOrderIdNoError as CancelOrderByClientOrderIdNoErrorIxAccounts,
        CancelOrderByClientOrderIdNoErrorInstructionArgs as CancelOrderByClientOrderIdNoErrorIxData,
        CancelOrderHalted as CancelOrderHaltedIxAccounts,
        CancelOrderHaltedInstructionArgs as CancelOrderHaltedIxData,
        CancelOrderInstructionArgs as CancelOrderIxData,
        CancelOrderNoError as CancelOrderNoErrorIxAccounts,
        CancelOrderNoErrorInstructionArgs as CancelOrderNoErrorIxData,
        ClaimReferralsRewards as ClaimReferralsRewardsIxAccounts,
        CleanZetaMarketHalted as CleanZetaMarketHaltedIxAccounts,
        CleanZetaMarketHaltedInstructionArgs as CleanZetaMarketHaltedIxData,
        CleanZetaMarkets as CleanZetaMarketsIxAccounts,
        CloseCrossMarginAccount as CloseCrossMarginAccountIxAccounts,
        CloseCrossMarginAccountInstructionArgs as CloseCrossMarginAccountIxData,
        CloseCrossMarginAccountManager as CloseCrossMarginAccountManagerIxAccounts,
        CloseMarginAccount as CloseMarginAccountIxAccounts,
        CloseOpenOrders as CloseOpenOrdersIxAccounts,
        CloseOpenOrdersInstructionArgs as CloseOpenOrdersIxData,
        CloseOpenOrdersV2 as CloseOpenOrdersV2IxAccounts,
        CloseOpenOrdersV2InstructionArgs as CloseOpenOrdersV2IxData,
        CloseOpenOrdersV3 as CloseOpenOrdersV3IxAccounts,
        CloseOpenOrdersV3InstructionArgs as CloseOpenOrdersV3IxData,
        CloseSpreadAccount as CloseSpreadAccountIxAccounts,
        CollectTreasuryFunds as CollectTreasuryFundsIxAccounts,
        CollectTreasuryFundsInstructionArgs as CollectTreasuryFundsIxData,
        CrankEventQueue as CrankEventQueueIxAccounts,
        CrankEventQueueInstructionArgs as CrankEventQueueIxData, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData,
        DepositInsuranceVault as DepositInsuranceVaultIxAccounts,
        DepositInsuranceVaultInstructionArgs as DepositInsuranceVaultIxData,
        DepositInsuranceVaultV2 as DepositInsuranceVaultV2IxAccounts,
        DepositInsuranceVaultV2InstructionArgs as DepositInsuranceVaultV2IxData,
        DepositV2 as DepositV2IxAccounts, DepositV2InstructionArgs as DepositV2IxData,
        EditDelegatedPubkey as EditDelegatedPubkeyIxAccounts,
        EditDelegatedPubkeyInstructionArgs as EditDelegatedPubkeyIxData,
        ExpireSeries as ExpireSeriesIxAccounts, ExpireSeriesInstructionArgs as ExpireSeriesIxData,
        ExpireSeriesOverride as ExpireSeriesOverrideIxAccounts,
        ExpireSeriesOverrideInstructionArgs as ExpireSeriesOverrideIxData,
        ForceCancelOrderByOrderId as ForceCancelOrderByOrderIdIxAccounts,
        ForceCancelOrderByOrderIdInstructionArgs as ForceCancelOrderByOrderIdIxData,
        ForceCancelOrderByOrderIdV2 as ForceCancelOrderByOrderIdV2IxAccounts,
        ForceCancelOrderByOrderIdV2InstructionArgs as ForceCancelOrderByOrderIdV2IxData,
        ForceCancelOrders as ForceCancelOrdersIxAccounts,
        ForceCancelOrdersInstructionArgs as ForceCancelOrdersIxData,
        ForceCancelOrdersV2 as ForceCancelOrdersV2IxAccounts,
        ForceCancelOrdersV2InstructionArgs as ForceCancelOrdersV2IxData, Halt as HaltIxAccounts,
        HaltInstructionArgs as HaltIxData,
        InitializeCombinedInsuranceVault as InitializeCombinedInsuranceVaultIxAccounts,
        InitializeCombinedInsuranceVaultInstructionArgs as InitializeCombinedInsuranceVaultIxData,
        InitializeCombinedSocializedLossAccount as InitializeCombinedSocializedLossAccountIxAccounts,
        InitializeCombinedSocializedLossAccountInstructionArgs as InitializeCombinedSocializedLossAccountIxData,
        InitializeCombinedVault as InitializeCombinedVaultIxAccounts,
        InitializeCombinedVaultInstructionArgs as InitializeCombinedVaultIxData,
        InitializeCrossMarginAccount as InitializeCrossMarginAccountIxAccounts,
        InitializeCrossMarginAccountInstructionArgs as InitializeCrossMarginAccountIxData,
        InitializeCrossMarginAccountManager as InitializeCrossMarginAccountManagerIxAccounts,
        InitializeInsuranceDepositAccount as InitializeInsuranceDepositAccountIxAccounts,
        InitializeInsuranceDepositAccountInstructionArgs as InitializeInsuranceDepositAccountIxData,
        InitializeMarginAccount as InitializeMarginAccountIxAccounts,
        InitializeMarketIndexes as InitializeMarketIndexesIxAccounts,
        InitializeMarketIndexesInstructionArgs as InitializeMarketIndexesIxData,
        InitializeMarketNode as InitializeMarketNodeIxAccounts,
        InitializeMarketNodeInstructionArgs as InitializeMarketNodeIxData,
        InitializeMarketStrikes as InitializeMarketStrikesIxAccounts,
        InitializeMarketTifEpochCycle as InitializeMarketTifEpochCycleIxAccounts,
        InitializeMarketTifEpochCycleInstructionArgs as InitializeMarketTifEpochCycleIxData,
        InitializeOpenOrders as InitializeOpenOrdersIxAccounts,
        InitializeOpenOrdersV2 as InitializeOpenOrdersV2IxAccounts,
        InitializeOpenOrdersV3 as InitializeOpenOrdersV3IxAccounts,
        InitializeOpenOrdersV3InstructionArgs as InitializeOpenOrdersV3IxData,
        InitializePerpSyncQueue as InitializePerpSyncQueueIxAccounts,
        InitializePerpSyncQueueInstructionArgs as InitializePerpSyncQueueIxData,
        InitializeReferrerAccount as InitializeReferrerAccountIxAccounts,
        InitializeReferrerAlias as InitializeReferrerAliasIxAccounts,
        InitializeReferrerAliasInstructionArgs as InitializeReferrerAliasIxData,
        InitializeSpreadAccount as InitializeSpreadAccountIxAccounts,
        InitializeUnderlying as InitializeUnderlyingIxAccounts,
        InitializeUnderlyingInstructionArgs as InitializeUnderlyingIxData,
        InitializeWhitelistDepositAccount as InitializeWhitelistDepositAccountIxAccounts,
        InitializeWhitelistDepositAccountInstructionArgs as InitializeWhitelistDepositAccountIxData,
        InitializeWhitelistInsuranceAccount as InitializeWhitelistInsuranceAccountIxAccounts,
        InitializeWhitelistInsuranceAccountInstructionArgs as InitializeWhitelistInsuranceAccountIxData,
        InitializeWhitelistTradingFeesAccount as InitializeWhitelistTradingFeesAccountIxAccounts,
        InitializeWhitelistTradingFeesAccountInstructionArgs as InitializeWhitelistTradingFeesAccountIxData,
        InitializeZetaGroup as InitializeZetaGroupIxAccounts,
        InitializeZetaGroupInstructionArgs as InitializeZetaGroupIxData,
        InitializeZetaMarket as InitializeZetaMarketIxAccounts,
        InitializeZetaMarketInstructionArgs as InitializeZetaMarketIxData,
        InitializeZetaPricing as InitializeZetaPricingIxAccounts,
        InitializeZetaPricingInstructionArgs as InitializeZetaPricingIxData,
        InitializeZetaReferralsRewardsWallet as InitializeZetaReferralsRewardsWalletIxAccounts,
        InitializeZetaState as InitializeZetaStateIxAccounts,
        InitializeZetaStateInstructionArgs as InitializeZetaStateIxData,
        InitializeZetaTreasuryWallet as InitializeZetaTreasuryWalletIxAccounts,
        Liquidate as LiquidateIxAccounts, LiquidateInstructionArgs as LiquidateIxData,
        LiquidateV2 as LiquidateV2IxAccounts, LiquidateV2InstructionArgs as LiquidateV2IxData,
        MigrateToCrossMarginAccount as MigrateToCrossMarginAccountIxAccounts,
        OverrideExpiry as OverrideExpiryIxAccounts,
        OverrideExpiryInstructionArgs as OverrideExpiryIxData, PlaceOrder as PlaceOrderIxAccounts,
        PlaceOrderInstructionArgs as PlaceOrderIxData, PlaceOrderV2 as PlaceOrderV2IxAccounts,
        PlaceOrderV2InstructionArgs as PlaceOrderV2IxData, PlaceOrderV3 as PlaceOrderV3IxAccounts,
        PlaceOrderV3InstructionArgs as PlaceOrderV3IxData, PlaceOrderV4 as PlaceOrderV4IxAccounts,
        PlaceOrderV4InstructionArgs as PlaceOrderV4IxData,
        PlacePerpOrder as PlacePerpOrderIxAccounts,
        PlacePerpOrderInstructionArgs as PlacePerpOrderIxData,
        PlacePerpOrderV2 as PlacePerpOrderV2IxAccounts,
        PlacePerpOrderV2InstructionArgs as PlacePerpOrderV2IxData,
        PlacePerpOrderV3 as PlacePerpOrderV3IxAccounts,
        PlacePerpOrderV3InstructionArgs as PlacePerpOrderV3IxData,
        PositionMovement as PositionMovementIxAccounts,
        PositionMovementInstructionArgs as PositionMovementIxData,
        PruneExpiredTifOrders as PruneExpiredTifOrdersIxAccounts,
        RebalanceInsuranceVault as RebalanceInsuranceVaultIxAccounts,
        ReferUser as ReferUserIxAccounts,
        ResetNumFlexUnderlyings as ResetNumFlexUnderlyingsIxAccounts,
        SetReferralsRewards as SetReferralsRewardsIxAccounts,
        SetReferralsRewardsInstructionArgs as SetReferralsRewardsIxData,
        SettleDexFunds as SettleDexFundsIxAccounts,
        SettlePositionsHalted as SettlePositionsHaltedIxAccounts,
        SettlePositionsHaltedInstructionArgs as SettlePositionsHaltedIxData,
        ToggleMarketMaker as ToggleMarketMakerIxAccounts,
        ToggleMarketMakerInstructionArgs as ToggleMarketMakerIxData,
        ToggleZetaGroupPerpsOnly as ToggleZetaGroupPerpsOnlyIxAccounts,
        TransferExcessSpreadBalance as TransferExcessSpreadBalanceIxAccounts,
        TreasuryMovement as TreasuryMovementIxAccounts,
        TreasuryMovementInstructionArgs as TreasuryMovementIxData, Unhalt as UnhaltIxAccounts,
        UnhaltInstructionArgs as UnhaltIxData, UpdateAdmin as UpdateAdminIxAccounts,
        UpdateHaltState as UpdateHaltStateIxAccounts,
        UpdateHaltStateInstructionArgs as UpdateHaltStateIxData,
        UpdateInterestRate as UpdateInterestRateIxAccounts,
        UpdateInterestRateInstructionArgs as UpdateInterestRateIxData,
        UpdateMarginParameters as UpdateMarginParametersIxAccounts,
        UpdateMarginParametersInstructionArgs as UpdateMarginParametersIxData,
        UpdateOracle as UpdateOracleIxAccounts,
        UpdateOracleBackupFeed as UpdateOracleBackupFeedIxAccounts,
        UpdatePerpParameters as UpdatePerpParametersIxAccounts,
        UpdatePerpParametersInstructionArgs as UpdatePerpParametersIxData,
        UpdatePricingParameters as UpdatePricingParametersIxAccounts,
        UpdatePricingParametersInstructionArgs as UpdatePricingParametersIxData,
        UpdatePricingV2 as UpdatePricingV2IxAccounts,
        UpdatePricingV2InstructionArgs as UpdatePricingV2IxData,
        UpdateReferralsAdmin as UpdateReferralsAdminIxAccounts,
        UpdateSecondaryAdmin as UpdateSecondaryAdminIxAccounts,
        UpdateVolatility as UpdateVolatilityIxAccounts,
        UpdateVolatilityInstructionArgs as UpdateVolatilityIxData,
        UpdateZetaGroupExpiryParameters as UpdateZetaGroupExpiryParametersIxAccounts,
        UpdateZetaGroupExpiryParametersInstructionArgs as UpdateZetaGroupExpiryParametersIxData,
        UpdateZetaGroupMarginParameters as UpdateZetaGroupMarginParametersIxAccounts,
        UpdateZetaGroupMarginParametersInstructionArgs as UpdateZetaGroupMarginParametersIxData,
        UpdateZetaGroupPerpParameters as UpdateZetaGroupPerpParametersIxAccounts,
        UpdateZetaGroupPerpParametersInstructionArgs as UpdateZetaGroupPerpParametersIxData,
        UpdateZetaPricingPubkeys as UpdateZetaPricingPubkeysIxAccounts,
        UpdateZetaPricingPubkeysInstructionArgs as UpdateZetaPricingPubkeysIxData,
        UpdateZetaState as UpdateZetaStateIxAccounts,
        UpdateZetaStateInstructionArgs as UpdateZetaStateIxData, Withdraw as WithdrawIxAccounts,
        WithdrawInstructionArgs as WithdrawIxData,
        WithdrawInsuranceVault as WithdrawInsuranceVaultIxAccounts,
        WithdrawInsuranceVaultInstructionArgs as WithdrawInsuranceVaultIxData,
        WithdrawInsuranceVaultV2 as WithdrawInsuranceVaultV2IxAccounts,
        WithdrawInsuranceVaultV2InstructionArgs as WithdrawInsuranceVaultV2IxData,
        WithdrawV2 as WithdrawV2IxAccounts, WithdrawV2InstructionArgs as WithdrawV2IxData,
    },
    ID,
};

/// Zeta Instructions
#[derive(Debug)]
pub enum ZetaProgramIx {
    InitializeZetaPricing(InitializeZetaPricingIxAccounts, InitializeZetaPricingIxData),
    UpdateZetaPricingPubkeys(
        UpdateZetaPricingPubkeysIxAccounts,
        UpdateZetaPricingPubkeysIxData,
    ),
    InitializeZetaGroup(InitializeZetaGroupIxAccounts, InitializeZetaGroupIxData),
    OverrideExpiry(OverrideExpiryIxAccounts, OverrideExpiryIxData),
    MigrateToCrossMarginAccount(MigrateToCrossMarginAccountIxAccounts),
    InitializeCrossMarginAccountManager(InitializeCrossMarginAccountManagerIxAccounts),
    InitializeCrossMarginAccount(
        InitializeCrossMarginAccountIxAccounts,
        InitializeCrossMarginAccountIxData,
    ),
    InitializeMarginAccount(InitializeMarginAccountIxAccounts),
    InitializeSpreadAccount(InitializeSpreadAccountIxAccounts),
    CloseCrossMarginAccountManager(CloseCrossMarginAccountManagerIxAccounts),
    CloseCrossMarginAccount(
        CloseCrossMarginAccountIxAccounts,
        CloseCrossMarginAccountIxData,
    ),
    CloseMarginAccount(CloseMarginAccountIxAccounts),
    CloseSpreadAccount(CloseSpreadAccountIxAccounts),
    InitializeUnderlying(InitializeUnderlyingIxAccounts, InitializeUnderlyingIxData),
    InitializePerpSyncQueue(
        InitializePerpSyncQueueIxAccounts,
        InitializePerpSyncQueueIxData,
    ),
    InitializeMarketIndexes(
        InitializeMarketIndexesIxAccounts,
        InitializeMarketIndexesIxData,
    ),
    InitializeMarketNode(InitializeMarketNodeIxAccounts, InitializeMarketNodeIxData),
    Halt(HaltIxAccounts, HaltIxData),
    Unhalt(UnhaltIxAccounts, UnhaltIxData),
    UpdateHaltState(UpdateHaltStateIxAccounts, UpdateHaltStateIxData),
    UpdateVolatility(UpdateVolatilityIxAccounts, UpdateVolatilityIxData),
    UpdateInterestRate(UpdateInterestRateIxAccounts, UpdateInterestRateIxData),
    AddPerpMarketIndex(AddPerpMarketIndexIxAccounts, AddPerpMarketIndexIxData),
    AddMarketIndexes(AddMarketIndexesIxAccounts),
    InitializeZetaState(InitializeZetaStateIxAccounts, InitializeZetaStateIxData),
    InitializeZetaTreasuryWallet(InitializeZetaTreasuryWalletIxAccounts),
    InitializeZetaReferralsRewardsWallet(InitializeZetaReferralsRewardsWalletIxAccounts),
    UpdateAdmin(UpdateAdminIxAccounts),
    UpdateSecondaryAdmin(UpdateSecondaryAdminIxAccounts),
    UpdateReferralsAdmin(UpdateReferralsAdminIxAccounts),
    UpdateZetaState(UpdateZetaStateIxAccounts, UpdateZetaStateIxData),
    UpdateOracle(UpdateOracleIxAccounts),
    UpdateOracleBackupFeed(UpdateOracleBackupFeedIxAccounts),
    UpdatePricingParameters(
        UpdatePricingParametersIxAccounts,
        UpdatePricingParametersIxData,
    ),
    UpdateMarginParameters(
        UpdateMarginParametersIxAccounts,
        UpdateMarginParametersIxData,
    ),
    UpdateZetaGroupMarginParameters(
        UpdateZetaGroupMarginParametersIxAccounts,
        UpdateZetaGroupMarginParametersIxData,
    ),
    UpdatePerpParameters(UpdatePerpParametersIxAccounts, UpdatePerpParametersIxData),
    UpdateZetaGroupPerpParameters(
        UpdateZetaGroupPerpParametersIxAccounts,
        UpdateZetaGroupPerpParametersIxData,
    ),
    UpdateZetaGroupExpiryParameters(
        UpdateZetaGroupExpiryParametersIxAccounts,
        UpdateZetaGroupExpiryParametersIxData,
    ),
    ToggleZetaGroupPerpsOnly(ToggleZetaGroupPerpsOnlyIxAccounts),
    CleanZetaMarkets(CleanZetaMarketsIxAccounts),
    CleanZetaMarketHalted(CleanZetaMarketHaltedIxAccounts, CleanZetaMarketHaltedIxData),
    SettlePositionsHalted(SettlePositionsHaltedIxAccounts, SettlePositionsHaltedIxData),
    InitializeMarketStrikes(InitializeMarketStrikesIxAccounts),
    ExpireSeriesOverride(ExpireSeriesOverrideIxAccounts, ExpireSeriesOverrideIxData),
    ExpireSeries(ExpireSeriesIxAccounts, ExpireSeriesIxData),
    InitializeZetaMarket(InitializeZetaMarketIxAccounts, InitializeZetaMarketIxData),
    InitializeMarketTifEpochCycle(
        InitializeMarketTifEpochCycleIxAccounts,
        InitializeMarketTifEpochCycleIxData,
    ),
    UpdatePricingV2(UpdatePricingV2IxAccounts, UpdatePricingV2IxData),
    ApplyPerpFunding(ApplyPerpFundingIxAccounts, ApplyPerpFundingIxData),
    Deposit(DepositIxAccounts, DepositIxData),
    DepositV2(DepositV2IxAccounts, DepositV2IxData),
    DepositInsuranceVault(DepositInsuranceVaultIxAccounts, DepositInsuranceVaultIxData),
    DepositInsuranceVaultV2(
        DepositInsuranceVaultV2IxAccounts,
        DepositInsuranceVaultV2IxData,
    ),
    Withdraw(WithdrawIxAccounts, WithdrawIxData),
    WithdrawV2(WithdrawV2IxAccounts, WithdrawV2IxData),
    WithdrawInsuranceVault(
        WithdrawInsuranceVaultIxAccounts,
        WithdrawInsuranceVaultIxData,
    ),
    WithdrawInsuranceVaultV2(
        WithdrawInsuranceVaultV2IxAccounts,
        WithdrawInsuranceVaultV2IxData,
    ),
    InitializeOpenOrders(InitializeOpenOrdersIxAccounts),
    InitializeOpenOrdersV2(InitializeOpenOrdersV2IxAccounts),
    InitializeOpenOrdersV3(
        InitializeOpenOrdersV3IxAccounts,
        InitializeOpenOrdersV3IxData,
    ),
    CloseOpenOrders(CloseOpenOrdersIxAccounts, CloseOpenOrdersIxData),
    CloseOpenOrdersV2(CloseOpenOrdersV2IxAccounts, CloseOpenOrdersV2IxData),
    CloseOpenOrdersV3(CloseOpenOrdersV3IxAccounts, CloseOpenOrdersV3IxData),
    InitializeWhitelistDepositAccount(
        InitializeWhitelistDepositAccountIxAccounts,
        InitializeWhitelistDepositAccountIxData,
    ),
    InitializeWhitelistInsuranceAccount(
        InitializeWhitelistInsuranceAccountIxAccounts,
        InitializeWhitelistInsuranceAccountIxData,
    ),
    InitializeWhitelistTradingFeesAccount(
        InitializeWhitelistTradingFeesAccountIxAccounts,
        InitializeWhitelistTradingFeesAccountIxData,
    ),
    InitializeInsuranceDepositAccount(
        InitializeInsuranceDepositAccountIxAccounts,
        InitializeInsuranceDepositAccountIxData,
    ),
    InitializeCombinedInsuranceVault(
        InitializeCombinedInsuranceVaultIxAccounts,
        InitializeCombinedInsuranceVaultIxData,
    ),
    InitializeCombinedVault(
        InitializeCombinedVaultIxAccounts,
        InitializeCombinedVaultIxData,
    ),
    InitializeCombinedSocializedLossAccount(
        InitializeCombinedSocializedLossAccountIxAccounts,
        InitializeCombinedSocializedLossAccountIxData,
    ),
    PlaceOrder(PlaceOrderIxAccounts, PlaceOrderIxData),
    PlaceOrderV2(PlaceOrderV2IxAccounts, PlaceOrderV2IxData),
    PlaceOrderV3(PlaceOrderV3IxAccounts, PlaceOrderV3IxData),
    PlacePerpOrder(PlacePerpOrderIxAccounts, PlacePerpOrderIxData),
    PlacePerpOrderV2(PlacePerpOrderV2IxAccounts, PlacePerpOrderV2IxData),
    PlaceOrderV4(PlaceOrderV4IxAccounts, PlaceOrderV4IxData),
    PlacePerpOrderV3(PlacePerpOrderV3IxAccounts, PlacePerpOrderV3IxData),
    CancelOrder(CancelOrderIxAccounts, CancelOrderIxData),
    CancelOrderNoError(CancelOrderNoErrorIxAccounts, CancelOrderNoErrorIxData),
    CancelAllMarketOrders(CancelAllMarketOrdersIxAccounts, CancelAllMarketOrdersIxData),
    CancelOrderHalted(CancelOrderHaltedIxAccounts, CancelOrderHaltedIxData),
    CancelOrderByClientOrderId(
        CancelOrderByClientOrderIdIxAccounts,
        CancelOrderByClientOrderIdIxData,
    ),
    CancelOrderByClientOrderIdNoError(
        CancelOrderByClientOrderIdNoErrorIxAccounts,
        CancelOrderByClientOrderIdNoErrorIxData,
    ),
    PruneExpiredTifOrders(PruneExpiredTifOrdersIxAccounts),
    ForceCancelOrderByOrderIdV2(
        ForceCancelOrderByOrderIdV2IxAccounts,
        ForceCancelOrderByOrderIdV2IxData,
    ),
    ForceCancelOrderByOrderId(
        ForceCancelOrderByOrderIdIxAccounts,
        ForceCancelOrderByOrderIdIxData,
    ),
    ForceCancelOrdersV2(ForceCancelOrdersV2IxAccounts, ForceCancelOrdersV2IxData),
    ForceCancelOrders(ForceCancelOrdersIxAccounts, ForceCancelOrdersIxData),
    CrankEventQueue(CrankEventQueueIxAccounts, CrankEventQueueIxData),
    CollectTreasuryFunds(CollectTreasuryFundsIxAccounts, CollectTreasuryFundsIxData),
    TreasuryMovement(TreasuryMovementIxAccounts, TreasuryMovementIxData),
    RebalanceInsuranceVault(RebalanceInsuranceVaultIxAccounts),
    LiquidateV2(LiquidateV2IxAccounts, LiquidateV2IxData),
    Liquidate(LiquidateIxAccounts, LiquidateIxData),
    BurnVaultTokens(BurnVaultTokensIxAccounts),
    SettleDexFunds(SettleDexFundsIxAccounts),
    PositionMovement(PositionMovementIxAccounts, PositionMovementIxData),
    TransferExcessSpreadBalance(TransferExcessSpreadBalanceIxAccounts),
    ToggleMarketMaker(ToggleMarketMakerIxAccounts, ToggleMarketMakerIxData),
    InitializeReferrerAccount(InitializeReferrerAccountIxAccounts),
    ReferUser(ReferUserIxAccounts),
    InitializeReferrerAlias(
        InitializeReferrerAliasIxAccounts,
        InitializeReferrerAliasIxData,
    ),
    SetReferralsRewards(SetReferralsRewardsIxAccounts, SetReferralsRewardsIxData),
    ClaimReferralsRewards(ClaimReferralsRewardsIxAccounts),
    EditDelegatedPubkey(EditDelegatedPubkeyIxAccounts, EditDelegatedPubkeyIxData),
    ResetNumFlexUnderlyings(ResetNumFlexUnderlyingsIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = ZetaProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Zeta::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<ZetaProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [35, 209, 180, 29, 245, 199, 125, 16] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeZetaPricingIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    rent: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    admin: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializeZetaPricingIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeZetaPricing(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [169, 221, 23, 248, 219, 122, 142, 158] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateZetaPricingPubkeysIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdateZetaPricingPubkeysIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateZetaPricingPubkeys(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [6, 135, 36, 232, 35, 39, 250, 71] => {
                check_min_accounts_req(accounts_len, 18)?;
                let ix_accounts = InitializeZetaGroupIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                    underlying_mint: ix.accounts[3].0.into(),
                    zeta_program: ix.accounts[4].0.into(),
                    oracle: ix.accounts[5].0.into(),
                    oracle_backup_feed: ix.accounts[6].0.into(),
                    oracle_backup_program: ix.accounts[7].0.into(),
                    zeta_group: ix.accounts[8].0.into(),
                    greeks: ix.accounts[9].0.into(),
                    perp_sync_queue: ix.accounts[10].0.into(),
                    underlying: ix.accounts[11].0.into(),
                    vault: ix.accounts[12].0.into(),
                    insurance_vault: ix.accounts[13].0.into(),
                    socialized_loss_account: ix.accounts[14].0.into(),
                    token_program: ix.accounts[15].0.into(),
                    usdc_mint: ix.accounts[16].0.into(),
                    rent: ix.accounts[17].0.into(),
                };
                let de_ix_data: InitializeZetaGroupIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeZetaGroup(ix_accounts, de_ix_data))
            },
            [129, 197, 117, 114, 108, 119, 207, 136] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = OverrideExpiryIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    zeta_group: ix.accounts[2].0.into(),
                };
                let de_ix_data: OverrideExpiryIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::OverrideExpiry(ix_accounts, de_ix_data))
            },
            [157, 53, 107, 104, 184, 189, 100, 220] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = MigrateToCrossMarginAccountIxAccounts {
                    cross_margin_account: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::MigrateToCrossMarginAccount(ix_accounts))
            },
            [72, 154, 15, 28, 165, 215, 209, 199] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeCrossMarginAccountManagerIxAccounts {
                    cross_margin_account_manager: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    payer: ix.accounts[2].0.into(),
                    zeta_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                Ok(ZetaProgramIx::InitializeCrossMarginAccountManager(
                    ix_accounts,
                ))
            },
            [27, 26, 228, 50, 210, 211, 205, 94] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeCrossMarginAccountIxAccounts {
                    cross_margin_account: ix.accounts[0].0.into(),
                    cross_margin_account_manager: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                    payer: ix.accounts[3].0.into(),
                    zeta_program: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializeCrossMarginAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeCrossMarginAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [67, 235, 66, 102, 167, 171, 120, 197] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeMarginAccountIxAccounts {
                    margin_account: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    payer: ix.accounts[2].0.into(),
                    zeta_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                    zeta_group: ix.accounts[5].0.into(),
                };
                Ok(ZetaProgramIx::InitializeMarginAccount(ix_accounts))
            },
            [206, 86, 251, 27, 91, 111, 23, 211] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeSpreadAccountIxAccounts {
                    spread_account: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    payer: ix.accounts[2].0.into(),
                    zeta_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                    zeta_group: ix.accounts[5].0.into(),
                };
                Ok(ZetaProgramIx::InitializeSpreadAccount(ix_accounts))
            },
            [232, 182, 182, 137, 86, 88, 118, 252] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = CloseCrossMarginAccountManagerIxAccounts {
                    cross_margin_account_manager: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                };
                Ok(ZetaProgramIx::CloseCrossMarginAccountManager(ix_accounts))
            },
            [203, 196, 187, 60, 13, 170, 190, 69] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CloseCrossMarginAccountIxAccounts {
                    cross_margin_account: ix.accounts[0].0.into(),
                    cross_margin_account_manager: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: CloseCrossMarginAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CloseCrossMarginAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [105, 215, 41, 239, 166, 207, 1, 103] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CloseMarginAccountIxAccounts {
                    margin_account: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    zeta_group: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::CloseMarginAccount(ix_accounts))
            },
            [190, 228, 253, 16, 201, 148, 161, 240] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CloseSpreadAccountIxAccounts {
                    spread_account: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    zeta_group: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::CloseSpreadAccount(ix_accounts))
            },
            [114, 108, 213, 92, 175, 124, 43, 19] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeUnderlyingIxAccounts {
                    admin: ix.accounts[0].0.into(),
                    zeta_program: ix.accounts[1].0.into(),
                    state: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    underlying: ix.accounts[4].0.into(),
                    underlying_mint: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializeUnderlyingIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeUnderlying(ix_accounts, de_ix_data))
            },
            [10, 55, 154, 224, 129, 174, 161, 8] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializePerpSyncQueueIxAccounts {
                    admin: ix.accounts[0].0.into(),
                    zeta_program: ix.accounts[1].0.into(),
                    state: ix.accounts[2].0.into(),
                    perp_sync_queue: ix.accounts[3].0.into(),
                    pricing: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializePerpSyncQueueIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializePerpSyncQueue(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [91, 63, 205, 144, 20, 83, 177, 120] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeMarketIndexesIxAccounts {
                    state: ix.accounts[0].0.into(),
                    market_indexes: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    pricing: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeMarketIndexesIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeMarketIndexes(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [50, 118, 21, 21, 179, 248, 23, 128] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeMarketNodeIxAccounts {
                    zeta_group: ix.accounts[0].0.into(),
                    market_node: ix.accounts[1].0.into(),
                    greeks: ix.accounts[2].0.into(),
                    payer: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeMarketNodeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeMarketNode(ix_accounts, de_ix_data))
            },
            [24, 156, 8, 121, 65, 3, 5, 82] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = HaltIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: HaltIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::Halt(ix_accounts, de_ix_data))
            },
            [249, 140, 27, 213, 128, 130, 207, 113] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UnhaltIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UnhaltIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::Unhalt(ix_accounts, de_ix_data))
            },
            [215, 45, 53, 162, 149, 138, 5, 63] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateHaltStateIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateHaltStateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateHaltState(ix_accounts, de_ix_data))
            },
            [190, 105, 116, 221, 229, 198, 208, 83] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateVolatilityIxAccounts {
                    state: ix.accounts[0].0.into(),
                    greeks: ix.accounts[1].0.into(),
                    zeta_group: ix.accounts[2].0.into(),
                    admin: ix.accounts[3].0.into(),
                };
                let de_ix_data: UpdateVolatilityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateVolatility(ix_accounts, de_ix_data))
            },
            [75, 8, 255, 41, 123, 59, 135, 238] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateInterestRateIxAccounts {
                    state: ix.accounts[0].0.into(),
                    greeks: ix.accounts[1].0.into(),
                    zeta_group: ix.accounts[2].0.into(),
                    admin: ix.accounts[3].0.into(),
                };
                let de_ix_data: UpdateInterestRateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateInterestRate(ix_accounts, de_ix_data))
            },
            [122, 40, 14, 64, 169, 18, 231, 136] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = AddPerpMarketIndexIxAccounts {
                    market_indexes: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                };
                let de_ix_data: AddPerpMarketIndexIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::AddPerpMarketIndex(ix_accounts, de_ix_data))
            },
            [94, 246, 144, 175, 4, 164, 233, 252] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = AddMarketIndexesIxAccounts {
                    market_indexes: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                };
                Ok(ZetaProgramIx::AddMarketIndexes(ix_accounts))
            },
            [68, 39, 75, 142, 191, 146, 94, 222] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = InitializeZetaStateIxAccounts {
                    state: ix.accounts[0].0.into(),
                    mint_authority: ix.accounts[1].0.into(),
                    serum_authority: ix.accounts[2].0.into(),
                    treasury_wallet: ix.accounts[3].0.into(),
                    referrals_admin: ix.accounts[4].0.into(),
                    referrals_rewards_wallet: ix.accounts[5].0.into(),
                    rent: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    usdc_mint: ix.accounts[9].0.into(),
                    admin: ix.accounts[10].0.into(),
                    secondary_admin: ix.accounts[11].0.into(),
                };
                let de_ix_data: InitializeZetaStateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeZetaState(ix_accounts, de_ix_data))
            },
            [249, 57, 187, 102, 184, 104, 37, 231] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = InitializeZetaTreasuryWalletIxAccounts {
                    state: ix.accounts[0].0.into(),
                    treasury_wallet: ix.accounts[1].0.into(),
                    rent: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    usdc_mint: ix.accounts[5].0.into(),
                    admin: ix.accounts[6].0.into(),
                };
                Ok(ZetaProgramIx::InitializeZetaTreasuryWallet(ix_accounts))
            },
            [245, 229, 223, 120, 7, 134, 247, 248] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = InitializeZetaReferralsRewardsWalletIxAccounts {
                    state: ix.accounts[0].0.into(),
                    referrals_rewards_wallet: ix.accounts[1].0.into(),
                    rent: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    usdc_mint: ix.accounts[5].0.into(),
                    admin: ix.accounts[6].0.into(),
                };
                Ok(ZetaProgramIx::InitializeZetaReferralsRewardsWallet(
                    ix_accounts,
                ))
            },
            [161, 176, 40, 213, 60, 184, 179, 228] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateAdminIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    new_admin: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::UpdateAdmin(ix_accounts))
            },
            [84, 230, 26, 75, 2, 179, 175, 234] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateSecondaryAdminIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    new_admin: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::UpdateSecondaryAdmin(ix_accounts))
            },
            [73, 144, 92, 119, 74, 106, 16, 200] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateReferralsAdminIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    new_admin: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::UpdateReferralsAdmin(ix_accounts))
            },
            [104, 182, 20, 187, 3, 164, 60, 3] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateZetaStateIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateZetaStateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateZetaState(ix_accounts, de_ix_data))
            },
            [112, 41, 209, 18, 248, 226, 252, 188] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateOracleIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                    oracle: ix.accounts[3].0.into(),
                };
                Ok(ZetaProgramIx::UpdateOracle(ix_accounts))
            },
            [230, 9, 33, 202, 228, 209, 180, 98] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateOracleBackupFeedIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                    oracle: ix.accounts[3].0.into(),
                };
                Ok(ZetaProgramIx::UpdateOracleBackupFeed(ix_accounts))
            },
            [105, 127, 208, 134, 61, 61, 113, 247] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdatePricingParametersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdatePricingParametersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdatePricingParameters(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [69, 50, 174, 197, 123, 196, 72, 236] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateMarginParametersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdateMarginParametersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateMarginParameters(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [60, 208, 121, 147, 242, 106, 11, 254] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateZetaGroupMarginParametersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdateZetaGroupMarginParametersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateZetaGroupMarginParameters(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [90, 135, 219, 42, 164, 134, 97, 174] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdatePerpParametersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdatePerpParametersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdatePerpParameters(ix_accounts, de_ix_data))
            },
            [72, 152, 140, 158, 195, 93, 247, 31] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateZetaGroupPerpParametersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdateZetaGroupPerpParametersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateZetaGroupPerpParameters(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [17, 69, 121, 104, 225, 206, 140, 215] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateZetaGroupExpiryParametersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdateZetaGroupExpiryParametersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdateZetaGroupExpiryParameters(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [170, 115, 77, 11, 161, 157, 247, 169] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ToggleZetaGroupPerpsOnlyIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::ToggleZetaGroupPerpsOnly(ix_accounts))
            },
            [122, 127, 49, 89, 68, 228, 85, 157] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = CleanZetaMarketsIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                };
                Ok(ZetaProgramIx::CleanZetaMarkets(ix_accounts))
            },
            [137, 140, 94, 18, 231, 232, 217, 204] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = CleanZetaMarketHaltedIxAccounts {
                    state: ix.accounts[0].0.into(),
                    market: ix.accounts[1].0.into(),
                    bids: ix.accounts[2].0.into(),
                    asks: ix.accounts[3].0.into(),
                };
                let de_ix_data: CleanZetaMarketHaltedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CleanZetaMarketHalted(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [170, 147, 139, 163, 19, 104, 167, 77] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SettlePositionsHaltedIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                };
                let de_ix_data: SettlePositionsHaltedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::SettlePositionsHalted(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [189, 46, 255, 33, 126, 133, 43, 171] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeMarketStrikesIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    oracle: ix.accounts[2].0.into(),
                    oracle_backup_feed: ix.accounts[3].0.into(),
                    oracle_backup_program: ix.accounts[4].0.into(),
                };
                Ok(ZetaProgramIx::InitializeMarketStrikes(ix_accounts))
            },
            [104, 22, 34, 123, 86, 224, 130, 70] => {
                check_min_accounts_req(accounts_len, 0)?;
                let ix_accounts = ExpireSeriesOverrideIxAccounts {};
                let de_ix_data: ExpireSeriesOverrideIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ExpireSeriesOverride(ix_accounts, de_ix_data))
            },
            [45, 162, 105, 98, 44, 21, 171, 127] => {
                check_min_accounts_req(accounts_len, 0)?;
                let ix_accounts = ExpireSeriesIxAccounts {};
                let de_ix_data: ExpireSeriesIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ExpireSeries(ix_accounts, de_ix_data))
            },
            [116, 239, 226, 149, 46, 163, 221, 3] => {
                check_min_accounts_req(accounts_len, 22)?;
                let ix_accounts = InitializeZetaMarketIxAccounts {
                    state: ix.accounts[0].0.into(),
                    market_indexes: ix.accounts[1].0.into(),
                    pricing: ix.accounts[2].0.into(),
                    admin: ix.accounts[3].0.into(),
                    market: ix.accounts[4].0.into(),
                    request_queue: ix.accounts[5].0.into(),
                    event_queue: ix.accounts[6].0.into(),
                    bids: ix.accounts[7].0.into(),
                    asks: ix.accounts[8].0.into(),
                    base_mint: ix.accounts[9].0.into(),
                    quote_mint: ix.accounts[10].0.into(),
                    zeta_base_vault: ix.accounts[11].0.into(),
                    zeta_quote_vault: ix.accounts[12].0.into(),
                    dex_base_vault: ix.accounts[13].0.into(),
                    dex_quote_vault: ix.accounts[14].0.into(),
                    vault_owner: ix.accounts[15].0.into(),
                    mint_authority: ix.accounts[16].0.into(),
                    serum_authority: ix.accounts[17].0.into(),
                    dex_program: ix.accounts[18].0.into(),
                    system_program: ix.accounts[19].0.into(),
                    token_program: ix.accounts[20].0.into(),
                    rent: ix.accounts[21].0.into(),
                };
                let de_ix_data: InitializeZetaMarketIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeZetaMarket(ix_accounts, de_ix_data))
            },
            [199, 143, 173, 147, 202, 204, 64, 204] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeMarketTifEpochCycleIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    market: ix.accounts[2].0.into(),
                    serum_authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeMarketTifEpochCycleIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeMarketTifEpochCycle(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [235, 109, 138, 173, 15, 37, 51, 244] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = UpdatePricingV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    oracle: ix.accounts[2].0.into(),
                    oracle_backup_feed: ix.accounts[3].0.into(),
                    oracle_backup_program: ix.accounts[4].0.into(),
                    perp_market: ix.accounts[5].0.into(),
                    perp_bids: ix.accounts[6].0.into(),
                    perp_asks: ix.accounts[7].0.into(),
                };
                let de_ix_data: UpdatePricingV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::UpdatePricingV2(ix_accounts, de_ix_data))
            },
            [23, 82, 225, 222, 219, 122, 230, 251] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ApplyPerpFundingIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                };
                let de_ix_data: ApplyPerpFundingIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ApplyPerpFunding(ix_accounts, de_ix_data))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = DepositIxAccounts {
                    zeta_group: ix.accounts[0].0.into(),
                    margin_account: ix.accounts[1].0.into(),
                    vault: ix.accounts[2].0.into(),
                    user_token_account: ix.accounts[3].0.into(),
                    socialized_loss_account: ix.accounts[4].0.into(),
                    authority: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    state: ix.accounts[7].0.into(),
                    greeks: ix.accounts[8].0.into(),
                };
                let de_ix_data: DepositIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [109, 75, 69, 153, 172, 218, 146, 19] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = DepositV2IxAccounts {
                    margin_account: ix.accounts[0].0.into(),
                    vault: ix.accounts[1].0.into(),
                    user_token_account: ix.accounts[2].0.into(),
                    socialized_loss_account: ix.accounts[3].0.into(),
                    authority: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    state: ix.accounts[6].0.into(),
                    pricing: ix.accounts[7].0.into(),
                };
                let de_ix_data: DepositV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::DepositV2(ix_accounts, de_ix_data))
            },
            [47, 53, 25, 47, 109, 122, 22, 22] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = DepositInsuranceVaultIxAccounts {
                    state: ix.accounts[0].0.into(),
                    insurance_vault: ix.accounts[1].0.into(),
                    insurance_deposit_account: ix.accounts[2].0.into(),
                    user_token_account: ix.accounts[3].0.into(),
                    zeta_vault: ix.accounts[4].0.into(),
                    socialized_loss_account: ix.accounts[5].0.into(),
                    authority: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: DepositInsuranceVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::DepositInsuranceVault(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [242, 44, 24, 19, 91, 59, 7, 201] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = DepositInsuranceVaultV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    insurance_vault: ix.accounts[2].0.into(),
                    insurance_deposit_account: ix.accounts[3].0.into(),
                    user_token_account: ix.accounts[4].0.into(),
                    zeta_vault: ix.accounts[5].0.into(),
                    socialized_loss_account: ix.accounts[6].0.into(),
                    authority: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: DepositInsuranceVaultV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::DepositInsuranceVaultV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [183, 18, 70, 156, 148, 109, 161, 34] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = WithdrawIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    vault: ix.accounts[2].0.into(),
                    margin_account: ix.accounts[3].0.into(),
                    user_token_account: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    oracle: ix.accounts[8].0.into(),
                    oracle_backup_feed: ix.accounts[9].0.into(),
                    oracle_backup_program: ix.accounts[10].0.into(),
                    socialized_loss_account: ix.accounts[11].0.into(),
                };
                let de_ix_data: WithdrawIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::Withdraw(ix_accounts, de_ix_data))
            },
            [242, 80, 163, 0, 196, 221, 194, 194] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = WithdrawV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    vault: ix.accounts[2].0.into(),
                    margin_account: ix.accounts[3].0.into(),
                    user_token_account: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    authority: ix.accounts[6].0.into(),
                    socialized_loss_account: ix.accounts[7].0.into(),
                };
                let de_ix_data: WithdrawV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::WithdrawV2(ix_accounts, de_ix_data))
            },
            [17, 250, 213, 45, 172, 117, 81, 225] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = WithdrawInsuranceVaultIxAccounts {
                    state: ix.accounts[0].0.into(),
                    insurance_vault: ix.accounts[1].0.into(),
                    insurance_deposit_account: ix.accounts[2].0.into(),
                    user_token_account: ix.accounts[3].0.into(),
                    authority: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: WithdrawInsuranceVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::WithdrawInsuranceVault(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [203, 71, 44, 148, 224, 242, 69, 165] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = WithdrawInsuranceVaultV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    insurance_vault: ix.accounts[2].0.into(),
                    insurance_deposit_account: ix.accounts[3].0.into(),
                    user_token_account: ix.accounts[4].0.into(),
                    authority: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: WithdrawInsuranceVaultV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::WithdrawInsuranceVaultV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [55, 234, 16, 82, 100, 42, 126, 192] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = InitializeOpenOrdersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    dex_program: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    open_orders: ix.accounts[4].0.into(),
                    margin_account: ix.accounts[5].0.into(),
                    authority: ix.accounts[6].0.into(),
                    payer: ix.accounts[7].0.into(),
                    market: ix.accounts[8].0.into(),
                    serum_authority: ix.accounts[9].0.into(),
                    open_orders_map: ix.accounts[10].0.into(),
                    rent: ix.accounts[11].0.into(),
                };
                Ok(ZetaProgramIx::InitializeOpenOrders(ix_accounts))
            },
            [220, 17, 85, 20, 112, 174, 148, 227] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = InitializeOpenOrdersV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    dex_program: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                    open_orders: ix.accounts[3].0.into(),
                    margin_account: ix.accounts[4].0.into(),
                    authority: ix.accounts[5].0.into(),
                    payer: ix.accounts[6].0.into(),
                    market: ix.accounts[7].0.into(),
                    serum_authority: ix.accounts[8].0.into(),
                    open_orders_map: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                };
                Ok(ZetaProgramIx::InitializeOpenOrdersV2(ix_accounts))
            },
            [22, 191, 139, 136, 121, 39, 84, 202] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = InitializeOpenOrdersV3IxAccounts {
                    state: ix.accounts[0].0.into(),
                    dex_program: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                    open_orders: ix.accounts[3].0.into(),
                    cross_margin_account: ix.accounts[4].0.into(),
                    authority: ix.accounts[5].0.into(),
                    payer: ix.accounts[6].0.into(),
                    market: ix.accounts[7].0.into(),
                    serum_authority: ix.accounts[8].0.into(),
                    open_orders_map: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                };
                let de_ix_data: InitializeOpenOrdersV3IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeOpenOrdersV3(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [200, 216, 63, 239, 7, 230, 255, 20] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CloseOpenOrdersIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    dex_program: ix.accounts[2].0.into(),
                    open_orders: ix.accounts[3].0.into(),
                    margin_account: ix.accounts[4].0.into(),
                    authority: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    serum_authority: ix.accounts[7].0.into(),
                    open_orders_map: ix.accounts[8].0.into(),
                };
                let de_ix_data: CloseOpenOrdersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CloseOpenOrders(ix_accounts, de_ix_data))
            },
            [78, 152, 196, 163, 68, 179, 121, 72] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = CloseOpenOrdersV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    dex_program: ix.accounts[1].0.into(),
                    open_orders: ix.accounts[2].0.into(),
                    margin_account: ix.accounts[3].0.into(),
                    authority: ix.accounts[4].0.into(),
                    market: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    open_orders_map: ix.accounts[7].0.into(),
                };
                let de_ix_data: CloseOpenOrdersV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CloseOpenOrdersV2(ix_accounts, de_ix_data))
            },
            [207, 15, 198, 74, 197, 228, 176, 30] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CloseOpenOrdersV3IxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    dex_program: ix.accounts[2].0.into(),
                    open_orders: ix.accounts[3].0.into(),
                    cross_margin_account: ix.accounts[4].0.into(),
                    authority: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    serum_authority: ix.accounts[7].0.into(),
                    open_orders_map: ix.accounts[8].0.into(),
                };
                let de_ix_data: CloseOpenOrdersV3IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CloseOpenOrdersV3(ix_accounts, de_ix_data))
            },
            [61, 231, 115, 219, 81, 243, 158, 138] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeWhitelistDepositAccountIxAccounts {
                    whitelist_deposit_account: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    user: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    state: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeWhitelistDepositAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeWhitelistDepositAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [43, 46, 240, 155, 80, 4, 86, 102] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeWhitelistInsuranceAccountIxAccounts {
                    whitelist_insurance_account: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    user: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    state: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeWhitelistInsuranceAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeWhitelistInsuranceAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [198, 129, 216, 185, 247, 29, 105, 190] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeWhitelistTradingFeesAccountIxAccounts {
                    whitelist_trading_fees_account: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    user: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    state: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeWhitelistTradingFeesAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeWhitelistTradingFeesAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [85, 163, 114, 121, 139, 167, 41, 37] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeInsuranceDepositAccountIxAccounts {
                    insurance_deposit_account: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    payer: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    whitelist_insurance_account: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeInsuranceDepositAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeInsuranceDepositAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [77, 18, 181, 144, 219, 84, 6, 106] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeCombinedInsuranceVaultIxAccounts {
                    state: ix.accounts[0].0.into(),
                    insurance_vault: ix.accounts[1].0.into(),
                    token_program: ix.accounts[2].0.into(),
                    usdc_mint: ix.accounts[3].0.into(),
                    admin: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializeCombinedInsuranceVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeCombinedInsuranceVault(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [59, 99, 105, 17, 73, 119, 229, 252] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeCombinedVaultIxAccounts {
                    state: ix.accounts[0].0.into(),
                    vault: ix.accounts[1].0.into(),
                    token_program: ix.accounts[2].0.into(),
                    usdc_mint: ix.accounts[3].0.into(),
                    admin: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializeCombinedVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeCombinedVault(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [136, 108, 88, 245, 230, 224, 101, 82] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = InitializeCombinedSocializedLossAccountIxAccounts {
                    state: ix.accounts[0].0.into(),
                    socialized_loss_account: ix.accounts[1].0.into(),
                    token_program: ix.accounts[2].0.into(),
                    usdc_mint: ix.accounts[3].0.into(),
                    admin: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: InitializeCombinedSocializedLossAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeCombinedSocializedLossAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [51, 194, 155, 175, 109, 130, 96, 106] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = PlaceOrderIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    request_queue: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                    bids: ix.accounts[13].0.into(),
                    asks: ix.accounts[14].0.into(),
                    order_payer_token_account: ix.accounts[15].0.into(),
                    coin_vault: ix.accounts[16].0.into(),
                    pc_vault: ix.accounts[17].0.into(),
                    coin_wallet: ix.accounts[18].0.into(),
                    pc_wallet: ix.accounts[19].0.into(),
                    oracle: ix.accounts[20].0.into(),
                    oracle_backup_feed: ix.accounts[21].0.into(),
                    oracle_backup_program: ix.accounts[22].0.into(),
                    market_node: ix.accounts[23].0.into(),
                    market_mint: ix.accounts[24].0.into(),
                    mint_authority: ix.accounts[25].0.into(),
                };
                let de_ix_data: PlaceOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlaceOrder(ix_accounts, de_ix_data))
            },
            [232, 111, 115, 196, 237, 143, 62, 204] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = PlaceOrderV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    request_queue: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                    bids: ix.accounts[13].0.into(),
                    asks: ix.accounts[14].0.into(),
                    order_payer_token_account: ix.accounts[15].0.into(),
                    coin_vault: ix.accounts[16].0.into(),
                    pc_vault: ix.accounts[17].0.into(),
                    coin_wallet: ix.accounts[18].0.into(),
                    pc_wallet: ix.accounts[19].0.into(),
                    oracle: ix.accounts[20].0.into(),
                    oracle_backup_feed: ix.accounts[21].0.into(),
                    oracle_backup_program: ix.accounts[22].0.into(),
                    market_node: ix.accounts[23].0.into(),
                    market_mint: ix.accounts[24].0.into(),
                    mint_authority: ix.accounts[25].0.into(),
                };
                let de_ix_data: PlaceOrderV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlaceOrderV2(ix_accounts, de_ix_data))
            },
            [146, 93, 14, 167, 159, 20, 6, 58] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = PlaceOrderV3IxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    request_queue: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                    bids: ix.accounts[13].0.into(),
                    asks: ix.accounts[14].0.into(),
                    order_payer_token_account: ix.accounts[15].0.into(),
                    coin_vault: ix.accounts[16].0.into(),
                    pc_vault: ix.accounts[17].0.into(),
                    coin_wallet: ix.accounts[18].0.into(),
                    pc_wallet: ix.accounts[19].0.into(),
                    oracle: ix.accounts[20].0.into(),
                    oracle_backup_feed: ix.accounts[21].0.into(),
                    oracle_backup_program: ix.accounts[22].0.into(),
                    market_node: ix.accounts[23].0.into(),
                    market_mint: ix.accounts[24].0.into(),
                    mint_authority: ix.accounts[25].0.into(),
                };
                let de_ix_data: PlaceOrderV3IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlaceOrderV3(ix_accounts, de_ix_data))
            },
            [69, 161, 93, 202, 120, 126, 76, 185] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = PlacePerpOrderIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    request_queue: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                    bids: ix.accounts[13].0.into(),
                    asks: ix.accounts[14].0.into(),
                    order_payer_token_account: ix.accounts[15].0.into(),
                    coin_vault: ix.accounts[16].0.into(),
                    pc_vault: ix.accounts[17].0.into(),
                    coin_wallet: ix.accounts[18].0.into(),
                    pc_wallet: ix.accounts[19].0.into(),
                    oracle: ix.accounts[20].0.into(),
                    oracle_backup_feed: ix.accounts[21].0.into(),
                    oracle_backup_program: ix.accounts[22].0.into(),
                    market_mint: ix.accounts[23].0.into(),
                    mint_authority: ix.accounts[24].0.into(),
                    perp_sync_queue: ix.accounts[25].0.into(),
                };
                let de_ix_data: PlacePerpOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlacePerpOrder(ix_accounts, de_ix_data))
            },
            [205, 84, 130, 180, 63, 118, 10, 207] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = PlacePerpOrderV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    request_queue: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                    bids: ix.accounts[13].0.into(),
                    asks: ix.accounts[14].0.into(),
                    order_payer_token_account: ix.accounts[15].0.into(),
                    coin_vault: ix.accounts[16].0.into(),
                    pc_vault: ix.accounts[17].0.into(),
                    coin_wallet: ix.accounts[18].0.into(),
                    pc_wallet: ix.accounts[19].0.into(),
                    oracle: ix.accounts[20].0.into(),
                    oracle_backup_feed: ix.accounts[21].0.into(),
                    oracle_backup_program: ix.accounts[22].0.into(),
                    market_mint: ix.accounts[23].0.into(),
                    mint_authority: ix.accounts[24].0.into(),
                    perp_sync_queue: ix.accounts[25].0.into(),
                };
                let de_ix_data: PlacePerpOrderV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlacePerpOrderV2(ix_accounts, de_ix_data))
            },
            [243, 248, 213, 143, 184, 79, 41, 73] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = PlaceOrderV4IxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    greeks: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    request_queue: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                    bids: ix.accounts[13].0.into(),
                    asks: ix.accounts[14].0.into(),
                    order_payer_token_account: ix.accounts[15].0.into(),
                    coin_vault: ix.accounts[16].0.into(),
                    pc_vault: ix.accounts[17].0.into(),
                    coin_wallet: ix.accounts[18].0.into(),
                    pc_wallet: ix.accounts[19].0.into(),
                    oracle: ix.accounts[20].0.into(),
                    oracle_backup_feed: ix.accounts[21].0.into(),
                    oracle_backup_program: ix.accounts[22].0.into(),
                    market_node: ix.accounts[23].0.into(),
                    market_mint: ix.accounts[24].0.into(),
                    mint_authority: ix.accounts[25].0.into(),
                };
                let de_ix_data: PlaceOrderV4IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlaceOrderV4(ix_accounts, de_ix_data))
            },
            [91, 246, 96, 7, 53, 22, 234, 225] => {
                check_min_accounts_req(accounts_len, 25)?;
                let ix_accounts = PlacePerpOrderV3IxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    serum_authority: ix.accounts[6].0.into(),
                    open_orders: ix.accounts[7].0.into(),
                    rent: ix.accounts[8].0.into(),
                    market: ix.accounts[9].0.into(),
                    request_queue: ix.accounts[10].0.into(),
                    event_queue: ix.accounts[11].0.into(),
                    bids: ix.accounts[12].0.into(),
                    asks: ix.accounts[13].0.into(),
                    order_payer_token_account: ix.accounts[14].0.into(),
                    coin_vault: ix.accounts[15].0.into(),
                    pc_vault: ix.accounts[16].0.into(),
                    coin_wallet: ix.accounts[17].0.into(),
                    pc_wallet: ix.accounts[18].0.into(),
                    oracle: ix.accounts[19].0.into(),
                    oracle_backup_feed: ix.accounts[20].0.into(),
                    oracle_backup_program: ix.accounts[21].0.into(),
                    market_mint: ix.accounts[22].0.into(),
                    mint_authority: ix.accounts[23].0.into(),
                    perp_sync_queue: ix.accounts[24].0.into(),
                };
                let de_ix_data: PlacePerpOrderV3IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PlacePerpOrderV3(ix_accounts, de_ix_data))
            },
            [95, 129, 237, 240, 8, 49, 223, 132] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = CancelOrderIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    state: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    serum_authority: ix.accounts[4].0.into(),
                    open_orders: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    bids: ix.accounts[7].0.into(),
                    asks: ix.accounts[8].0.into(),
                    event_queue: ix.accounts[9].0.into(),
                };
                let de_ix_data: CancelOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CancelOrder(ix_accounts, de_ix_data))
            },
            [95, 97, 215, 204, 111, 51, 204, 184] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = CancelOrderNoErrorIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    state: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    serum_authority: ix.accounts[4].0.into(),
                    open_orders: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    bids: ix.accounts[7].0.into(),
                    asks: ix.accounts[8].0.into(),
                    event_queue: ix.accounts[9].0.into(),
                };
                let de_ix_data: CancelOrderNoErrorIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CancelOrderNoError(ix_accounts, de_ix_data))
            },
            [139, 190, 230, 249, 77, 160, 206, 4] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = CancelAllMarketOrdersIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    state: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    serum_authority: ix.accounts[4].0.into(),
                    open_orders: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    bids: ix.accounts[7].0.into(),
                    asks: ix.accounts[8].0.into(),
                    event_queue: ix.accounts[9].0.into(),
                };
                let de_ix_data: CancelAllMarketOrdersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CancelAllMarketOrders(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [0, 192, 233, 2, 252, 251, 130, 169] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CancelOrderHaltedIxAccounts {
                    state: ix.accounts[0].0.into(),
                    margin_account: ix.accounts[1].0.into(),
                    dex_program: ix.accounts[2].0.into(),
                    serum_authority: ix.accounts[3].0.into(),
                    open_orders: ix.accounts[4].0.into(),
                    market: ix.accounts[5].0.into(),
                    bids: ix.accounts[6].0.into(),
                    asks: ix.accounts[7].0.into(),
                    event_queue: ix.accounts[8].0.into(),
                };
                let de_ix_data: CancelOrderHaltedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CancelOrderHalted(ix_accounts, de_ix_data))
            },
            [115, 178, 201, 8, 175, 183, 123, 119] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = CancelOrderByClientOrderIdIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    state: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    serum_authority: ix.accounts[4].0.into(),
                    open_orders: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    bids: ix.accounts[7].0.into(),
                    asks: ix.accounts[8].0.into(),
                    event_queue: ix.accounts[9].0.into(),
                };
                let de_ix_data: CancelOrderByClientOrderIdIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CancelOrderByClientOrderId(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [53, 77, 167, 157, 175, 131, 144, 171] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = CancelOrderByClientOrderIdNoErrorIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    state: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    serum_authority: ix.accounts[4].0.into(),
                    open_orders: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                    bids: ix.accounts[7].0.into(),
                    asks: ix.accounts[8].0.into(),
                    event_queue: ix.accounts[9].0.into(),
                };
                let de_ix_data: CancelOrderByClientOrderIdNoErrorIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CancelOrderByClientOrderIdNoError(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [24, 227, 226, 212, 93, 26, 242, 230] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = PruneExpiredTifOrdersIxAccounts {
                    dex_program: ix.accounts[0].0.into(),
                    state: ix.accounts[1].0.into(),
                    serum_authority: ix.accounts[2].0.into(),
                    market: ix.accounts[3].0.into(),
                    bids: ix.accounts[4].0.into(),
                    asks: ix.accounts[5].0.into(),
                    event_queue: ix.accounts[6].0.into(),
                };
                Ok(ZetaProgramIx::PruneExpiredTifOrders(ix_accounts))
            },
            [81, 243, 60, 90, 222, 201, 41, 222] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = ForceCancelOrderByOrderIdV2IxAccounts {
                    pricing: ix.accounts[0].0.into(),
                    oracle: ix.accounts[1].0.into(),
                    oracle_backup_feed: ix.accounts[2].0.into(),
                    oracle_backup_program: ix.accounts[3].0.into(),
                    state: ix.accounts[4].0.into(),
                    margin_account: ix.accounts[5].0.into(),
                    dex_program: ix.accounts[6].0.into(),
                    serum_authority: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    market: ix.accounts[9].0.into(),
                    bids: ix.accounts[10].0.into(),
                    asks: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                };
                let de_ix_data: ForceCancelOrderByOrderIdV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ForceCancelOrderByOrderIdV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [182, 235, 48, 179, 248, 133, 210, 240] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = ForceCancelOrderByOrderIdIxAccounts {
                    zeta_group: ix.accounts[0].0.into(),
                    greeks: ix.accounts[1].0.into(),
                    oracle: ix.accounts[2].0.into(),
                    oracle_backup_feed: ix.accounts[3].0.into(),
                    oracle_backup_program: ix.accounts[4].0.into(),
                    state: ix.accounts[5].0.into(),
                    margin_account: ix.accounts[6].0.into(),
                    dex_program: ix.accounts[7].0.into(),
                    serum_authority: ix.accounts[8].0.into(),
                    open_orders: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    bids: ix.accounts[11].0.into(),
                    asks: ix.accounts[12].0.into(),
                    event_queue: ix.accounts[13].0.into(),
                };
                let de_ix_data: ForceCancelOrderByOrderIdIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ForceCancelOrderByOrderId(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [14, 62, 149, 202, 143, 17, 56, 115] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = ForceCancelOrdersV2IxAccounts {
                    pricing: ix.accounts[0].0.into(),
                    oracle: ix.accounts[1].0.into(),
                    oracle_backup_feed: ix.accounts[2].0.into(),
                    oracle_backup_program: ix.accounts[3].0.into(),
                    state: ix.accounts[4].0.into(),
                    margin_account: ix.accounts[5].0.into(),
                    dex_program: ix.accounts[6].0.into(),
                    serum_authority: ix.accounts[7].0.into(),
                    open_orders: ix.accounts[8].0.into(),
                    market: ix.accounts[9].0.into(),
                    bids: ix.accounts[10].0.into(),
                    asks: ix.accounts[11].0.into(),
                    event_queue: ix.accounts[12].0.into(),
                };
                let de_ix_data: ForceCancelOrdersV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ForceCancelOrdersV2(ix_accounts, de_ix_data))
            },
            [64, 181, 196, 63, 222, 72, 64, 232] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = ForceCancelOrdersIxAccounts {
                    zeta_group: ix.accounts[0].0.into(),
                    greeks: ix.accounts[1].0.into(),
                    oracle: ix.accounts[2].0.into(),
                    oracle_backup_feed: ix.accounts[3].0.into(),
                    oracle_backup_program: ix.accounts[4].0.into(),
                    state: ix.accounts[5].0.into(),
                    margin_account: ix.accounts[6].0.into(),
                    dex_program: ix.accounts[7].0.into(),
                    serum_authority: ix.accounts[8].0.into(),
                    open_orders: ix.accounts[9].0.into(),
                    market: ix.accounts[10].0.into(),
                    bids: ix.accounts[11].0.into(),
                    asks: ix.accounts[12].0.into(),
                    event_queue: ix.accounts[13].0.into(),
                };
                let de_ix_data: ForceCancelOrdersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ForceCancelOrders(ix_accounts, de_ix_data))
            },
            [67, 133, 97, 223, 178, 188, 235, 181] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CrankEventQueueIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pricing: ix.accounts[1].0.into(),
                    market: ix.accounts[2].0.into(),
                    event_queue: ix.accounts[3].0.into(),
                    dex_program: ix.accounts[4].0.into(),
                    serum_authority: ix.accounts[5].0.into(),
                    perp_sync_queue: ix.accounts[6].0.into(),
                };
                let de_ix_data: CrankEventQueueIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CrankEventQueue(ix_accounts, de_ix_data))
            },
            [243, 213, 4, 236, 26, 246, 180, 174] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CollectTreasuryFundsIxAccounts {
                    state: ix.accounts[0].0.into(),
                    treasury_wallet: ix.accounts[1].0.into(),
                    collection_token_account: ix.accounts[2].0.into(),
                    token_program: ix.accounts[3].0.into(),
                    admin: ix.accounts[4].0.into(),
                };
                let de_ix_data: CollectTreasuryFundsIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::CollectTreasuryFunds(ix_accounts, de_ix_data))
            },
            [1, 34, 242, 105, 215, 211, 157, 18] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = TreasuryMovementIxAccounts {
                    state: ix.accounts[0].0.into(),
                    insurance_vault: ix.accounts[1].0.into(),
                    treasury_wallet: ix.accounts[2].0.into(),
                    referrals_rewards_wallet: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    admin: ix.accounts[5].0.into(),
                };
                let de_ix_data: TreasuryMovementIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::TreasuryMovement(ix_accounts, de_ix_data))
            },
            [11, 196, 66, 235, 59, 237, 223, 111] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = RebalanceInsuranceVaultIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_vault: ix.accounts[1].0.into(),
                    insurance_vault: ix.accounts[2].0.into(),
                    treasury_wallet: ix.accounts[3].0.into(),
                    socialized_loss_account: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                Ok(ZetaProgramIx::RebalanceInsuranceVault(ix_accounts))
            },
            [15, 86, 85, 55, 2, 225, 161, 235] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = LiquidateV2IxAccounts {
                    state: ix.accounts[0].0.into(),
                    liquidator: ix.accounts[1].0.into(),
                    liquidator_account: ix.accounts[2].0.into(),
                    pricing: ix.accounts[3].0.into(),
                    oracle: ix.accounts[4].0.into(),
                    oracle_backup_feed: ix.accounts[5].0.into(),
                    oracle_backup_program: ix.accounts[6].0.into(),
                    market: ix.accounts[7].0.into(),
                    liquidated_account: ix.accounts[8].0.into(),
                };
                let de_ix_data: LiquidateV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::LiquidateV2(ix_accounts, de_ix_data))
            },
            [223, 179, 226, 125, 48, 46, 39, 74] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = LiquidateIxAccounts {
                    state: ix.accounts[0].0.into(),
                    liquidator: ix.accounts[1].0.into(),
                    liquidator_margin_account: ix.accounts[2].0.into(),
                    greeks: ix.accounts[3].0.into(),
                    oracle: ix.accounts[4].0.into(),
                    oracle_backup_feed: ix.accounts[5].0.into(),
                    oracle_backup_program: ix.accounts[6].0.into(),
                    market: ix.accounts[7].0.into(),
                    zeta_group: ix.accounts[8].0.into(),
                    liquidated_margin_account: ix.accounts[9].0.into(),
                };
                let de_ix_data: LiquidateIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::Liquidate(ix_accounts, de_ix_data))
            },
            [233, 203, 165, 201, 175, 43, 188, 159] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = BurnVaultTokensIxAccounts {
                    state: ix.accounts[0].0.into(),
                    mint: ix.accounts[1].0.into(),
                    vault: ix.accounts[2].0.into(),
                    serum_authority: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                };
                Ok(ZetaProgramIx::BurnVaultTokens(ix_accounts))
            },
            [165, 103, 142, 38, 211, 166, 14, 226] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = SettleDexFundsIxAccounts {
                    state: ix.accounts[0].0.into(),
                    market: ix.accounts[1].0.into(),
                    zeta_base_vault: ix.accounts[2].0.into(),
                    zeta_quote_vault: ix.accounts[3].0.into(),
                    dex_base_vault: ix.accounts[4].0.into(),
                    dex_quote_vault: ix.accounts[5].0.into(),
                    vault_owner: ix.accounts[6].0.into(),
                    mint_authority: ix.accounts[7].0.into(),
                    serum_authority: ix.accounts[8].0.into(),
                    dex_program: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                };
                Ok(ZetaProgramIx::SettleDexFunds(ix_accounts))
            },
            [117, 16, 75, 249, 179, 127, 171, 147] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = PositionMovementIxAccounts {
                    state: ix.accounts[0].0.into(),
                    zeta_group: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                    spread_account: ix.accounts[3].0.into(),
                    authority: ix.accounts[4].0.into(),
                    greeks: ix.accounts[5].0.into(),
                    oracle: ix.accounts[6].0.into(),
                    oracle_backup_feed: ix.accounts[7].0.into(),
                    oracle_backup_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: PositionMovementIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::PositionMovement(ix_accounts, de_ix_data))
            },
            [172, 184, 12, 10, 52, 105, 64, 213] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = TransferExcessSpreadBalanceIxAccounts {
                    zeta_group: ix.accounts[0].0.into(),
                    margin_account: ix.accounts[1].0.into(),
                    spread_account: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                };
                Ok(ZetaProgramIx::TransferExcessSpreadBalance(ix_accounts))
            },
            [203, 247, 84, 159, 104, 253, 148, 80] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ToggleMarketMakerIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    margin_account: ix.accounts[2].0.into(),
                };
                let de_ix_data: ToggleMarketMakerIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::ToggleMarketMaker(ix_accounts, de_ix_data))
            },
            [45, 92, 202, 68, 71, 67, 51, 4] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = InitializeReferrerAccountIxAccounts {
                    referrer: ix.accounts[0].0.into(),
                    referrer_account: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                Ok(ZetaProgramIx::InitializeReferrerAccount(ix_accounts))
            },
            [57, 114, 154, 204, 185, 33, 170, 136] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = ReferUserIxAccounts {
                    user: ix.accounts[0].0.into(),
                    referrer_account: ix.accounts[1].0.into(),
                    referral_account: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                };
                Ok(ZetaProgramIx::ReferUser(ix_accounts))
            },
            [67, 28, 3, 78, 140, 108, 20, 138] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = InitializeReferrerAliasIxAccounts {
                    referrer: ix.accounts[0].0.into(),
                    referrer_alias: ix.accounts[1].0.into(),
                    referrer_account: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                };
                let de_ix_data: InitializeReferrerAliasIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::InitializeReferrerAlias(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [62, 232, 1, 18, 75, 7, 77, 158] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetReferralsRewardsIxAccounts {
                    state: ix.accounts[0].0.into(),
                    referrals_admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: SetReferralsRewardsIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::SetReferralsRewards(ix_accounts, de_ix_data))
            },
            [121, 156, 109, 159, 158, 219, 217, 143] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = ClaimReferralsRewardsIxAccounts {
                    state: ix.accounts[0].0.into(),
                    referrals_rewards_wallet: ix.accounts[1].0.into(),
                    user_referrals_account: ix.accounts[2].0.into(),
                    user_token_account: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    user: ix.accounts[5].0.into(),
                };
                Ok(ZetaProgramIx::ClaimReferralsRewards(ix_accounts))
            },
            [137, 245, 71, 89, 46, 249, 22, 53] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = EditDelegatedPubkeyIxAccounts {
                    margin_account: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: EditDelegatedPubkeyIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(ZetaProgramIx::EditDelegatedPubkey(ix_accounts, de_ix_data))
            },
            [48, 19, 254, 209, 200, 211, 49, 61] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ResetNumFlexUnderlyingsIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                Ok(ZetaProgramIx::ResetNumFlexUnderlyings(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
