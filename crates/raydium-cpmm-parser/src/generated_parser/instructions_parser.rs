//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CollectFundFee as CollectFundFeeIxAccounts,
        CollectFundFeeInstructionArgs as CollectFundFeeIxData,
        CollectProtocolFee as CollectProtocolFeeIxAccounts,
        CollectProtocolFeeInstructionArgs as CollectProtocolFeeIxData,
        CreateAmmConfig as CreateAmmConfigIxAccounts,
        CreateAmmConfigInstructionArgs as CreateAmmConfigIxData, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData, Initialize as InitializeIxAccounts,
        InitializeInstructionArgs as InitializeIxData, SwapBaseInput as SwapBaseInputIxAccounts,
        SwapBaseInputInstructionArgs as SwapBaseInputIxData,
        SwapBaseOutput as SwapBaseOutputIxAccounts,
        SwapBaseOutputInstructionArgs as SwapBaseOutputIxData,
        UpdateAmmConfig as UpdateAmmConfigIxAccounts,
        UpdateAmmConfigInstructionArgs as UpdateAmmConfigIxData,
        UpdatePoolStatus as UpdatePoolStatusIxAccounts,
        UpdatePoolStatusInstructionArgs as UpdatePoolStatusIxData, Withdraw as WithdrawIxAccounts,
        WithdrawInstructionArgs as WithdrawIxData,
    },
    ID,
};

/// RaydiumCpSwap Instructions
#[derive(Debug)]
pub enum RaydiumCpSwapProgramIx {
    CreateAmmConfig(CreateAmmConfigIxAccounts, CreateAmmConfigIxData),
    UpdateAmmConfig(UpdateAmmConfigIxAccounts, UpdateAmmConfigIxData),
    UpdatePoolStatus(UpdatePoolStatusIxAccounts, UpdatePoolStatusIxData),
    CollectProtocolFee(CollectProtocolFeeIxAccounts, CollectProtocolFeeIxData),
    CollectFundFee(CollectFundFeeIxAccounts, CollectFundFeeIxData),
    Initialize(InitializeIxAccounts, InitializeIxData),
    Deposit(DepositIxAccounts, DepositIxData),
    Withdraw(WithdrawIxAccounts, WithdrawIxData),
    SwapBaseInput(SwapBaseInputIxAccounts, SwapBaseInputIxData),
    SwapBaseOutput(SwapBaseOutputIxAccounts, SwapBaseOutputIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = RaydiumCpSwapProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "RaydiumCpSwap::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<RaydiumCpSwapProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [137, 52, 237, 212, 215, 117, 108, 104] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CreateAmmConfigIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    amm_config: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: CreateAmmConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::CreateAmmConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [49, 60, 174, 136, 154, 28, 116, 200] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateAmmConfigIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    amm_config: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateAmmConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::UpdateAmmConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [130, 87, 108, 6, 46, 224, 117, 123] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdatePoolStatusIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    pool_state: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdatePoolStatusIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::UpdatePoolStatus(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [136, 136, 252, 221, 194, 66, 126, 89] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = CollectProtocolFeeIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    amm_config: ix.accounts[3].0.into(),
                    token0_vault: ix.accounts[4].0.into(),
                    token1_vault: ix.accounts[5].0.into(),
                    vault0_mint: ix.accounts[6].0.into(),
                    vault1_mint: ix.accounts[7].0.into(),
                    recipient_token0_account: ix.accounts[8].0.into(),
                    recipient_token1_account: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    token_program2022: ix.accounts[11].0.into(),
                };
                let de_ix_data: CollectProtocolFeeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::CollectProtocolFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [167, 138, 78, 149, 223, 194, 6, 126] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = CollectFundFeeIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    amm_config: ix.accounts[3].0.into(),
                    token0_vault: ix.accounts[4].0.into(),
                    token1_vault: ix.accounts[5].0.into(),
                    vault0_mint: ix.accounts[6].0.into(),
                    vault1_mint: ix.accounts[7].0.into(),
                    recipient_token0_account: ix.accounts[8].0.into(),
                    recipient_token1_account: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    token_program2022: ix.accounts[11].0.into(),
                };
                let de_ix_data: CollectFundFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::CollectFundFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                check_min_accounts_req(accounts_len, 20)?;
                let ix_accounts = InitializeIxAccounts {
                    creator: ix.accounts[0].0.into(),
                    amm_config: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                    pool_state: ix.accounts[3].0.into(),
                    token0_mint: ix.accounts[4].0.into(),
                    token1_mint: ix.accounts[5].0.into(),
                    lp_mint: ix.accounts[6].0.into(),
                    creator_token0: ix.accounts[7].0.into(),
                    creator_token1: ix.accounts[8].0.into(),
                    creator_lp_token: ix.accounts[9].0.into(),
                    token0_vault: ix.accounts[10].0.into(),
                    token1_vault: ix.accounts[11].0.into(),
                    create_pool_fee: ix.accounts[12].0.into(),
                    observation_state: ix.accounts[13].0.into(),
                    token_program: ix.accounts[14].0.into(),
                    token0_program: ix.accounts[15].0.into(),
                    token1_program: ix.accounts[16].0.into(),
                    associated_token_program: ix.accounts[17].0.into(),
                    system_program: ix.accounts[18].0.into(),
                    rent: ix.accounts[19].0.into(),
                };
                let de_ix_data: InitializeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::Initialize(ix_accounts, de_ix_data))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = DepositIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    owner_lp_token: ix.accounts[3].0.into(),
                    token0_account: ix.accounts[4].0.into(),
                    token1_account: ix.accounts[5].0.into(),
                    token0_vault: ix.accounts[6].0.into(),
                    token1_vault: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    token_program2022: ix.accounts[9].0.into(),
                    vault0_mint: ix.accounts[10].0.into(),
                    vault1_mint: ix.accounts[11].0.into(),
                    lp_mint: ix.accounts[12].0.into(),
                };
                let de_ix_data: DepositIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [183, 18, 70, 156, 148, 109, 161, 34] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = WithdrawIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    owner_lp_token: ix.accounts[3].0.into(),
                    token0_account: ix.accounts[4].0.into(),
                    token1_account: ix.accounts[5].0.into(),
                    token0_vault: ix.accounts[6].0.into(),
                    token1_vault: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    token_program2022: ix.accounts[9].0.into(),
                    vault0_mint: ix.accounts[10].0.into(),
                    vault1_mint: ix.accounts[11].0.into(),
                    lp_mint: ix.accounts[12].0.into(),
                    memo_program: ix.accounts[13].0.into(),
                };
                let de_ix_data: WithdrawIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::Withdraw(ix_accounts, de_ix_data))
            },
            [143, 190, 90, 218, 196, 30, 51, 222] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = SwapBaseInputIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    amm_config: ix.accounts[2].0.into(),
                    pool_state: ix.accounts[3].0.into(),
                    input_token_account: ix.accounts[4].0.into(),
                    output_token_account: ix.accounts[5].0.into(),
                    input_vault: ix.accounts[6].0.into(),
                    output_vault: ix.accounts[7].0.into(),
                    input_token_program: ix.accounts[8].0.into(),
                    output_token_program: ix.accounts[9].0.into(),
                    input_token_mint: ix.accounts[10].0.into(),
                    output_token_mint: ix.accounts[11].0.into(),
                    observation_state: ix.accounts[12].0.into(),
                };
                let de_ix_data: SwapBaseInputIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::SwapBaseInput(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [55, 217, 98, 86, 163, 74, 180, 173] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = SwapBaseOutputIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    amm_config: ix.accounts[2].0.into(),
                    pool_state: ix.accounts[3].0.into(),
                    input_token_account: ix.accounts[4].0.into(),
                    output_token_account: ix.accounts[5].0.into(),
                    input_vault: ix.accounts[6].0.into(),
                    output_vault: ix.accounts[7].0.into(),
                    input_token_program: ix.accounts[8].0.into(),
                    output_token_program: ix.accounts[9].0.into(),
                    input_token_mint: ix.accounts[10].0.into(),
                    output_token_mint: ix.accounts[11].0.into(),
                    observation_state: ix.accounts[12].0.into(),
                };
                let de_ix_data: SwapBaseOutputIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::SwapBaseOutput(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
