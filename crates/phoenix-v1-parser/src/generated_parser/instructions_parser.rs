//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize};
use crate::ID;
use crate::instructions::{SwapInstructionArgs as SwapIxData, Swap as SwapIxAccounts, SwapWithFreeFundsInstructionArgs as SwapWithFreeFundsIxData, SwapWithFreeFunds as SwapWithFreeFundsIxAccounts, PlaceLimitOrderInstructionArgs as PlaceLimitOrderIxData, PlaceLimitOrder as PlaceLimitOrderIxAccounts, PlaceLimitOrderWithFreeFundsInstructionArgs as PlaceLimitOrderWithFreeFundsIxData, PlaceLimitOrderWithFreeFunds as PlaceLimitOrderWithFreeFundsIxAccounts, ReduceOrderInstructionArgs as ReduceOrderIxData, ReduceOrder as ReduceOrderIxAccounts, ReduceOrderWithFreeFundsInstructionArgs as ReduceOrderWithFreeFundsIxData, ReduceOrderWithFreeFunds as ReduceOrderWithFreeFundsIxAccounts, CancelAllOrders as CancelAllOrdersIxAccounts, CancelAllOrdersWithFreeFunds as CancelAllOrdersWithFreeFundsIxAccounts, CancelUpToInstructionArgs as CancelUpToIxData, CancelUpTo as CancelUpToIxAccounts, CancelUpToWithFreeFundsInstructionArgs as CancelUpToWithFreeFundsIxData, CancelUpToWithFreeFunds as CancelUpToWithFreeFundsIxAccounts, CancelMultipleOrdersByIdInstructionArgs as CancelMultipleOrdersByIdIxData, CancelMultipleOrdersById as CancelMultipleOrdersByIdIxAccounts, CancelMultipleOrdersByIdWithFreeFundsInstructionArgs as CancelMultipleOrdersByIdWithFreeFundsIxData, CancelMultipleOrdersByIdWithFreeFunds as CancelMultipleOrdersByIdWithFreeFundsIxAccounts, WithdrawFundsInstructionArgs as WithdrawFundsIxData, WithdrawFunds as WithdrawFundsIxAccounts, DepositFundsInstructionArgs as DepositFundsIxData, DepositFunds as DepositFundsIxAccounts, RequestSeat as RequestSeatIxAccounts, Log as LogIxAccounts, PlaceMultiplePostOnlyOrdersInstructionArgs as PlaceMultiplePostOnlyOrdersIxData, PlaceMultiplePostOnlyOrders as PlaceMultiplePostOnlyOrdersIxAccounts, PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs as PlaceMultiplePostOnlyOrdersWithFreeFundsIxData, PlaceMultiplePostOnlyOrdersWithFreeFunds as PlaceMultiplePostOnlyOrdersWithFreeFundsIxAccounts, InitializeMarketInstructionArgs as InitializeMarketIxData, InitializeMarket as InitializeMarketIxAccounts, ClaimAuthority as ClaimAuthorityIxAccounts, NameSuccessorInstructionArgs as NameSuccessorIxData, NameSuccessor as NameSuccessorIxAccounts, ChangeMarketStatusInstructionArgs as ChangeMarketStatusIxData, ChangeMarketStatus as ChangeMarketStatusIxAccounts, ChangeSeatStatusInstructionArgs as ChangeSeatStatusIxData, ChangeSeatStatus as ChangeSeatStatusIxAccounts, RequestSeatAuthorized as RequestSeatAuthorizedIxAccounts, EvictSeat as EvictSeatIxAccounts, ForceCancelOrdersInstructionArgs as ForceCancelOrdersIxData, ForceCancelOrders as ForceCancelOrdersIxAccounts, CollectFees as CollectFeesIxAccounts, ChangeFeeRecipient as ChangeFeeRecipientIxAccounts, };

/// PhoenixV1 Instructions
#[derive(Debug)]
pub enum PhoenixV1ProgramIx {
                        Swap(SwapIxAccounts, SwapIxData),
                                SwapWithFreeFunds(SwapWithFreeFundsIxAccounts, SwapWithFreeFundsIxData),
                                PlaceLimitOrder(PlaceLimitOrderIxAccounts, PlaceLimitOrderIxData),
                                PlaceLimitOrderWithFreeFunds(PlaceLimitOrderWithFreeFundsIxAccounts, PlaceLimitOrderWithFreeFundsIxData),
                                ReduceOrder(ReduceOrderIxAccounts, ReduceOrderIxData),
                                ReduceOrderWithFreeFunds(ReduceOrderWithFreeFundsIxAccounts, ReduceOrderWithFreeFundsIxData),
                                CancelAllOrders(CancelAllOrdersIxAccounts),
                                CancelAllOrdersWithFreeFunds(CancelAllOrdersWithFreeFundsIxAccounts),
                                CancelUpTo(CancelUpToIxAccounts, CancelUpToIxData),
                                CancelUpToWithFreeFunds(CancelUpToWithFreeFundsIxAccounts, CancelUpToWithFreeFundsIxData),
                                CancelMultipleOrdersById(CancelMultipleOrdersByIdIxAccounts, CancelMultipleOrdersByIdIxData),
                                CancelMultipleOrdersByIdWithFreeFunds(CancelMultipleOrdersByIdWithFreeFundsIxAccounts, CancelMultipleOrdersByIdWithFreeFundsIxData),
                                WithdrawFunds(WithdrawFundsIxAccounts, WithdrawFundsIxData),
                                DepositFunds(DepositFundsIxAccounts, DepositFundsIxData),
                                RequestSeat(RequestSeatIxAccounts),
                                Log(LogIxAccounts),
                                PlaceMultiplePostOnlyOrders(PlaceMultiplePostOnlyOrdersIxAccounts, PlaceMultiplePostOnlyOrdersIxData),
                                PlaceMultiplePostOnlyOrdersWithFreeFunds(PlaceMultiplePostOnlyOrdersWithFreeFundsIxAccounts, PlaceMultiplePostOnlyOrdersWithFreeFundsIxData),
                                InitializeMarket(InitializeMarketIxAccounts, InitializeMarketIxData),
                                ClaimAuthority(ClaimAuthorityIxAccounts),
                                NameSuccessor(NameSuccessorIxAccounts, NameSuccessorIxData),
                                ChangeMarketStatus(ChangeMarketStatusIxAccounts, ChangeMarketStatusIxData),
                                ChangeSeatStatus(ChangeSeatStatusIxAccounts, ChangeSeatStatusIxData),
                                RequestSeatAuthorized(RequestSeatAuthorizedIxAccounts),
                                EvictSeat(EvictSeatIxAccounts),
                                ForceCancelOrders(ForceCancelOrdersIxAccounts, ForceCancelOrdersIxData),
                                CollectFees(CollectFeesIxAccounts),
                                ChangeFeeRecipient(ChangeFeeRecipientIxAccounts),
            }

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = PhoenixV1ProgramIx;

    fn id(&self) -> std::borrow::Cow<str> {
        "PhoenixV1::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(&self, ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(ix:&yellowstone_vixen_core::instruction::InstructionUpdate) -> yellowstone_vixen_core::ParseResult<PhoenixV1ProgramIx> {
        let accounts_len = ix.accounts.len();
                let ix_discriminator:[u8; 1] = ix.data[0..1].try_into()?;
        let mut ix_data = &ix.data[1..];
            match ix_discriminator {
                                                                                        [0] => {
                                check_min_accounts_req(accounts_len, 9)?;
                                let ix_accounts = SwapIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            base_account: ix.accounts[4].0.into(),
                                                                            quote_account: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            token_program: ix.accounts[8].0.into(),
                                                                    };
                                                                    let de_ix_data:SwapIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::Swap(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [1] => {
                                check_min_accounts_req(accounts_len, 5)?;
                                let ix_accounts = SwapWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                    };
                                                                    let de_ix_data:SwapWithFreeFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::SwapWithFreeFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [2] => {
                                check_min_accounts_req(accounts_len, 10)?;
                                let ix_accounts = PlaceLimitOrderIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                            base_account: ix.accounts[5].0.into(),
                                                                            quote_account: ix.accounts[6].0.into(),
                                                                            base_vault: ix.accounts[7].0.into(),
                                                                            quote_vault: ix.accounts[8].0.into(),
                                                                            token_program: ix.accounts[9].0.into(),
                                                                    };
                                                                    let de_ix_data:PlaceLimitOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::PlaceLimitOrder(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [3] => {
                                check_min_accounts_req(accounts_len, 5)?;
                                let ix_accounts = PlaceLimitOrderWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                    };
                                                                    let de_ix_data:PlaceLimitOrderWithFreeFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::PlaceLimitOrderWithFreeFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [4] => {
                                check_min_accounts_req(accounts_len, 9)?;
                                let ix_accounts = ReduceOrderIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            base_account: ix.accounts[4].0.into(),
                                                                            quote_account: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            token_program: ix.accounts[8].0.into(),
                                                                    };
                                                                    let de_ix_data:ReduceOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::ReduceOrder(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [5] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = ReduceOrderWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                    };
                                                                    let de_ix_data:ReduceOrderWithFreeFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::ReduceOrderWithFreeFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [6] => {
                                check_min_accounts_req(accounts_len, 9)?;
                                let ix_accounts = CancelAllOrdersIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            base_account: ix.accounts[4].0.into(),
                                                                            quote_account: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            token_program: ix.accounts[8].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::CancelAllOrders(ix_accounts))
                                                            },
                                                                                                                                    [7] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = CancelAllOrdersWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::CancelAllOrdersWithFreeFunds(ix_accounts))
                                                            },
                                                                                                                                    [8] => {
                                check_min_accounts_req(accounts_len, 9)?;
                                let ix_accounts = CancelUpToIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            base_account: ix.accounts[4].0.into(),
                                                                            quote_account: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            token_program: ix.accounts[8].0.into(),
                                                                    };
                                                                    let de_ix_data:CancelUpToIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::CancelUpTo(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [9] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = CancelUpToWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                    };
                                                                    let de_ix_data:CancelUpToWithFreeFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::CancelUpToWithFreeFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [10] => {
                                check_min_accounts_req(accounts_len, 9)?;
                                let ix_accounts = CancelMultipleOrdersByIdIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            base_account: ix.accounts[4].0.into(),
                                                                            quote_account: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            token_program: ix.accounts[8].0.into(),
                                                                    };
                                                                    let de_ix_data:CancelMultipleOrdersByIdIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::CancelMultipleOrdersById(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [11] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = CancelMultipleOrdersByIdWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                    };
                                                                    let de_ix_data:CancelMultipleOrdersByIdWithFreeFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::CancelMultipleOrdersByIdWithFreeFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [12] => {
                                check_min_accounts_req(accounts_len, 9)?;
                                let ix_accounts = WithdrawFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            base_account: ix.accounts[4].0.into(),
                                                                            quote_account: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            token_program: ix.accounts[8].0.into(),
                                                                    };
                                                                    let de_ix_data:WithdrawFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::WithdrawFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [13] => {
                                check_min_accounts_req(accounts_len, 10)?;
                                let ix_accounts = DepositFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                            base_account: ix.accounts[5].0.into(),
                                                                            quote_account: ix.accounts[6].0.into(),
                                                                            base_vault: ix.accounts[7].0.into(),
                                                                            quote_vault: ix.accounts[8].0.into(),
                                                                            token_program: ix.accounts[9].0.into(),
                                                                    };
                                                                    let de_ix_data:DepositFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::DepositFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [14] => {
                                check_min_accounts_req(accounts_len, 6)?;
                                let ix_accounts = RequestSeatIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            payer: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                            system_program: ix.accounts[5].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::RequestSeat(ix_accounts))
                                                            },
                                                                                                                                    [15] => {
                                check_min_accounts_req(accounts_len, 1)?;
                                let ix_accounts = LogIxAccounts{
                                                                            log_authority: ix.accounts[0].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::Log(ix_accounts))
                                                            },
                                                                                                                                    [16] => {
                                check_min_accounts_req(accounts_len, 10)?;
                                let ix_accounts = PlaceMultiplePostOnlyOrdersIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                            base_account: ix.accounts[5].0.into(),
                                                                            quote_account: ix.accounts[6].0.into(),
                                                                            base_vault: ix.accounts[7].0.into(),
                                                                            quote_vault: ix.accounts[8].0.into(),
                                                                            token_program: ix.accounts[9].0.into(),
                                                                    };
                                                                    let de_ix_data:PlaceMultiplePostOnlyOrdersIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::PlaceMultiplePostOnlyOrders(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [17] => {
                                check_min_accounts_req(accounts_len, 5)?;
                                let ix_accounts = PlaceMultiplePostOnlyOrdersWithFreeFundsIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            trader: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                    };
                                                                    let de_ix_data:PlaceMultiplePostOnlyOrdersWithFreeFundsIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::PlaceMultiplePostOnlyOrdersWithFreeFunds(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [100] => {
                                check_min_accounts_req(accounts_len, 10)?;
                                let ix_accounts = InitializeMarketIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_creator: ix.accounts[3].0.into(),
                                                                            base_mint: ix.accounts[4].0.into(),
                                                                            quote_mint: ix.accounts[5].0.into(),
                                                                            base_vault: ix.accounts[6].0.into(),
                                                                            quote_vault: ix.accounts[7].0.into(),
                                                                            system_program: ix.accounts[8].0.into(),
                                                                            token_program: ix.accounts[9].0.into(),
                                                                    };
                                                                    let de_ix_data:InitializeMarketIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::InitializeMarket(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [101] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = ClaimAuthorityIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            successor: ix.accounts[3].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::ClaimAuthority(ix_accounts))
                                                            },
                                                                                                                                    [102] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = NameSuccessorIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                    };
                                                                    let de_ix_data:NameSuccessorIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::NameSuccessor(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [103] => {
                                check_min_accounts_req(accounts_len, 4)?;
                                let ix_accounts = ChangeMarketStatusIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                    };
                                                                    let de_ix_data:ChangeMarketStatusIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::ChangeMarketStatus(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [104] => {
                                check_min_accounts_req(accounts_len, 5)?;
                                let ix_accounts = ChangeSeatStatusIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                            seat: ix.accounts[4].0.into(),
                                                                    };
                                                                    let de_ix_data:ChangeSeatStatusIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::ChangeSeatStatus(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [105] => {
                                check_min_accounts_req(accounts_len, 8)?;
                                let ix_accounts = RequestSeatAuthorizedIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                            payer: ix.accounts[4].0.into(),
                                                                            trader: ix.accounts[5].0.into(),
                                                                            seat: ix.accounts[6].0.into(),
                                                                            system_program: ix.accounts[7].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::RequestSeatAuthorized(ix_accounts))
                                                            },
                                                                                                                                    [106] => {
                                check_min_accounts_req(accounts_len, 11)?;
                                let ix_accounts = EvictSeatIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                            trader: ix.accounts[4].0.into(),
                                                                            seat: ix.accounts[5].0.into(),
                                                                            base_account: ix.accounts[6].0.into(),
                                                                            quote_account: ix.accounts[7].0.into(),
                                                                            base_vault: ix.accounts[8].0.into(),
                                                                            quote_vault: ix.accounts[9].0.into(),
                                                                            token_program: ix.accounts[10].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::EvictSeat(ix_accounts))
                                                            },
                                                                                                                                    [107] => {
                                check_min_accounts_req(accounts_len, 11)?;
                                let ix_accounts = ForceCancelOrdersIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                            trader: ix.accounts[4].0.into(),
                                                                            seat: ix.accounts[5].0.into(),
                                                                            base_account: ix.accounts[6].0.into(),
                                                                            quote_account: ix.accounts[7].0.into(),
                                                                            base_vault: ix.accounts[8].0.into(),
                                                                            quote_vault: ix.accounts[9].0.into(),
                                                                            token_program: ix.accounts[10].0.into(),
                                                                    };
                                                                    let de_ix_data:ForceCancelOrdersIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                                    Ok(PhoenixV1ProgramIx::ForceCancelOrders(ix_accounts, de_ix_data))
                                                            },
                                                                                                                                    [108] => {
                                check_min_accounts_req(accounts_len, 7)?;
                                let ix_accounts = CollectFeesIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            sweeper: ix.accounts[3].0.into(),
                                                                            fee_recipient: ix.accounts[4].0.into(),
                                                                            quote_vault: ix.accounts[5].0.into(),
                                                                            token_program: ix.accounts[6].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::CollectFees(ix_accounts))
                                                            },
                                                                                                                                    [109] => {
                                check_min_accounts_req(accounts_len, 5)?;
                                let ix_accounts = ChangeFeeRecipientIxAccounts{
                                                                            phoenix_program: ix.accounts[0].0.into(),
                                                                            log_authority: ix.accounts[1].0.into(),
                                                                            market: ix.accounts[2].0.into(),
                                                                            market_authority: ix.accounts[3].0.into(),
                                                                            new_fee_recipient: ix.accounts[4].0.into(),
                                                                    };
                                                                    Ok(PhoenixV1ProgramIx::ChangeFeeRecipient(ix_accounts))
                                                            },
                                                                            _ => Err(yellowstone_vixen_core::ParseError::from("Invalid Instruction discriminator".to_owned())),
            }
            }

}

pub fn check_min_accounts_req(actual: usize, expected: usize) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

