//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        AddLiquidity as AddLiquidityIxAccounts, AddLiquidityInstructionArgs as AddLiquidityIxData,
        AddValidator as AddValidatorIxAccounts, AddValidatorInstructionArgs as AddValidatorIxData,
        ChangeAuthority as ChangeAuthorityIxAccounts,
        ChangeAuthorityInstructionArgs as ChangeAuthorityIxData, Claim as ClaimIxAccounts,
        ConfigLp as ConfigLpIxAccounts, ConfigLpInstructionArgs as ConfigLpIxData,
        ConfigMarinade as ConfigMarinadeIxAccounts,
        ConfigMarinadeInstructionArgs as ConfigMarinadeIxData,
        ConfigValidatorSystem as ConfigValidatorSystemIxAccounts,
        ConfigValidatorSystemInstructionArgs as ConfigValidatorSystemIxData,
        DeactivateStake as DeactivateStakeIxAccounts,
        DeactivateStakeInstructionArgs as DeactivateStakeIxData, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData,
        DepositStakeAccount as DepositStakeAccountIxAccounts,
        DepositStakeAccountInstructionArgs as DepositStakeAccountIxData,
        EmergencyUnstake as EmergencyUnstakeIxAccounts,
        EmergencyUnstakeInstructionArgs as EmergencyUnstakeIxData,
        Initialize as InitializeIxAccounts, InitializeInstructionArgs as InitializeIxData,
        LiquidUnstake as LiquidUnstakeIxAccounts,
        LiquidUnstakeInstructionArgs as LiquidUnstakeIxData, MergeStakes as MergeStakesIxAccounts,
        MergeStakesInstructionArgs as MergeStakesIxData, OrderUnstake as OrderUnstakeIxAccounts,
        OrderUnstakeInstructionArgs as OrderUnstakeIxData,
        PartialUnstake as PartialUnstakeIxAccounts,
        PartialUnstakeInstructionArgs as PartialUnstakeIxData, Pause as PauseIxAccounts,
        ReallocStakeList as ReallocStakeListIxAccounts,
        ReallocStakeListInstructionArgs as ReallocStakeListIxData,
        ReallocValidatorList as ReallocValidatorListIxAccounts,
        ReallocValidatorListInstructionArgs as ReallocValidatorListIxData,
        Redelegate as RedelegateIxAccounts, RedelegateInstructionArgs as RedelegateIxData,
        RemoveLiquidity as RemoveLiquidityIxAccounts,
        RemoveLiquidityInstructionArgs as RemoveLiquidityIxData,
        RemoveValidator as RemoveValidatorIxAccounts,
        RemoveValidatorInstructionArgs as RemoveValidatorIxData, Resume as ResumeIxAccounts,
        SetValidatorScore as SetValidatorScoreIxAccounts,
        SetValidatorScoreInstructionArgs as SetValidatorScoreIxData,
        StakeReserve as StakeReserveIxAccounts, StakeReserveInstructionArgs as StakeReserveIxData,
        UpdateActive as UpdateActiveIxAccounts, UpdateActiveInstructionArgs as UpdateActiveIxData,
        UpdateDeactivated as UpdateDeactivatedIxAccounts,
        UpdateDeactivatedInstructionArgs as UpdateDeactivatedIxData,
        WithdrawStakeAccount as WithdrawStakeAccountIxAccounts,
        WithdrawStakeAccountInstructionArgs as WithdrawStakeAccountIxData,
    },
    ID,
};

/// MarinadeFinance Instructions
#[derive(Debug)]
pub enum MarinadeFinanceProgramIx {
    Initialize(InitializeIxAccounts, InitializeIxData),
    ChangeAuthority(ChangeAuthorityIxAccounts, ChangeAuthorityIxData),
    AddValidator(AddValidatorIxAccounts, AddValidatorIxData),
    RemoveValidator(RemoveValidatorIxAccounts, RemoveValidatorIxData),
    SetValidatorScore(SetValidatorScoreIxAccounts, SetValidatorScoreIxData),
    ConfigValidatorSystem(ConfigValidatorSystemIxAccounts, ConfigValidatorSystemIxData),
    Deposit(DepositIxAccounts, DepositIxData),
    DepositStakeAccount(DepositStakeAccountIxAccounts, DepositStakeAccountIxData),
    LiquidUnstake(LiquidUnstakeIxAccounts, LiquidUnstakeIxData),
    AddLiquidity(AddLiquidityIxAccounts, AddLiquidityIxData),
    RemoveLiquidity(RemoveLiquidityIxAccounts, RemoveLiquidityIxData),
    ConfigLp(ConfigLpIxAccounts, ConfigLpIxData),
    ConfigMarinade(ConfigMarinadeIxAccounts, ConfigMarinadeIxData),
    OrderUnstake(OrderUnstakeIxAccounts, OrderUnstakeIxData),
    Claim(ClaimIxAccounts),
    StakeReserve(StakeReserveIxAccounts, StakeReserveIxData),
    UpdateActive(UpdateActiveIxAccounts, UpdateActiveIxData),
    UpdateDeactivated(UpdateDeactivatedIxAccounts, UpdateDeactivatedIxData),
    DeactivateStake(DeactivateStakeIxAccounts, DeactivateStakeIxData),
    EmergencyUnstake(EmergencyUnstakeIxAccounts, EmergencyUnstakeIxData),
    PartialUnstake(PartialUnstakeIxAccounts, PartialUnstakeIxData),
    MergeStakes(MergeStakesIxAccounts, MergeStakesIxData),
    Redelegate(RedelegateIxAccounts, RedelegateIxData),
    Pause(PauseIxAccounts),
    Resume(ResumeIxAccounts),
    WithdrawStakeAccount(WithdrawStakeAccountIxAccounts, WithdrawStakeAccountIxData),
    ReallocValidatorList(ReallocValidatorListIxAccounts, ReallocValidatorListIxData),
    ReallocStakeList(ReallocStakeListIxAccounts, ReallocStakeListIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = MarinadeFinanceProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "MarinadeFinance::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<MarinadeFinanceProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = InitializeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    reserve_pda: ix.accounts[1].0.into(),
                    stake_list: ix.accounts[2].0.into(),
                    validator_list: ix.accounts[3].0.into(),
                    msol_mint: ix.accounts[4].0.into(),
                    operational_sol_account: ix.accounts[5].0.into(),
                    lp_mint: ix.accounts[6].0.into(),
                    sol_leg_pda: ix.accounts[7].0.into(),
                    msol_leg: ix.accounts[8].0.into(),
                    treasury_msol_account: ix.accounts[9].0.into(),
                    clock: ix.accounts[10].0.into(),
                    rent: ix.accounts[11].0.into(),
                };
                let de_ix_data: InitializeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::Initialize(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [50, 106, 66, 104, 99, 118, 145, 88] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ChangeAuthorityIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: ChangeAuthorityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::ChangeAuthority(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [250, 113, 53, 54, 141, 117, 215, 185] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = AddValidatorIxAccounts {
                    state: ix.accounts[0].0.into(),
                    manager_authority: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    validator_vote: ix.accounts[3].0.into(),
                    duplication_flag: ix.accounts[4].0.into(),
                    rent_payer: ix.accounts[5].0.into(),
                    clock: ix.accounts[6].0.into(),
                    rent: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: AddValidatorIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::AddValidator(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [25, 96, 211, 155, 161, 14, 168, 188] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = RemoveValidatorIxAccounts {
                    state: ix.accounts[0].0.into(),
                    manager_authority: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    duplication_flag: ix.accounts[3].0.into(),
                    operational_sol_account: ix.accounts[4].0.into(),
                };
                let de_ix_data: RemoveValidatorIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::RemoveValidator(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [101, 41, 206, 33, 216, 111, 25, 78] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetValidatorScoreIxAccounts {
                    state: ix.accounts[0].0.into(),
                    manager_authority: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetValidatorScoreIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::SetValidatorScore(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [27, 90, 97, 209, 17, 115, 7, 40] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ConfigValidatorSystemIxAccounts {
                    state: ix.accounts[0].0.into(),
                    manager_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: ConfigValidatorSystemIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::ConfigValidatorSystem(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = DepositIxAccounts {
                    state: ix.accounts[0].0.into(),
                    msol_mint: ix.accounts[1].0.into(),
                    liq_pool_sol_leg_pda: ix.accounts[2].0.into(),
                    liq_pool_msol_leg: ix.accounts[3].0.into(),
                    liq_pool_msol_leg_authority: ix.accounts[4].0.into(),
                    reserve_pda: ix.accounts[5].0.into(),
                    transfer_from: ix.accounts[6].0.into(),
                    mint_to: ix.accounts[7].0.into(),
                    msol_mint_authority: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: DepositIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [110, 130, 115, 41, 164, 102, 2, 59] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = DepositStakeAccountIxAccounts {
                    state: ix.accounts[0].0.into(),
                    validator_list: ix.accounts[1].0.into(),
                    stake_list: ix.accounts[2].0.into(),
                    stake_account: ix.accounts[3].0.into(),
                    stake_authority: ix.accounts[4].0.into(),
                    duplication_flag: ix.accounts[5].0.into(),
                    rent_payer: ix.accounts[6].0.into(),
                    msol_mint: ix.accounts[7].0.into(),
                    mint_to: ix.accounts[8].0.into(),
                    msol_mint_authority: ix.accounts[9].0.into(),
                    clock: ix.accounts[10].0.into(),
                    rent: ix.accounts[11].0.into(),
                    system_program: ix.accounts[12].0.into(),
                    token_program: ix.accounts[13].0.into(),
                    stake_program: ix.accounts[14].0.into(),
                };
                let de_ix_data: DepositStakeAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::DepositStakeAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [30, 30, 119, 240, 191, 227, 12, 16] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = LiquidUnstakeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    msol_mint: ix.accounts[1].0.into(),
                    liq_pool_sol_leg_pda: ix.accounts[2].0.into(),
                    liq_pool_msol_leg: ix.accounts[3].0.into(),
                    treasury_msol_account: ix.accounts[4].0.into(),
                    get_msol_from: ix.accounts[5].0.into(),
                    get_msol_from_authority: ix.accounts[6].0.into(),
                    transfer_sol_to: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                    token_program: ix.accounts[9].0.into(),
                };
                let de_ix_data: LiquidUnstakeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::LiquidUnstake(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [181, 157, 89, 67, 143, 182, 52, 72] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = AddLiquidityIxAccounts {
                    state: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    lp_mint_authority: ix.accounts[2].0.into(),
                    liq_pool_msol_leg: ix.accounts[3].0.into(),
                    liq_pool_sol_leg_pda: ix.accounts[4].0.into(),
                    transfer_from: ix.accounts[5].0.into(),
                    mint_to: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: AddLiquidityIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::AddLiquidity(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [80, 85, 209, 72, 24, 206, 177, 108] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = RemoveLiquidityIxAccounts {
                    state: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    burn_from: ix.accounts[2].0.into(),
                    burn_from_authority: ix.accounts[3].0.into(),
                    transfer_sol_to: ix.accounts[4].0.into(),
                    transfer_msol_to: ix.accounts[5].0.into(),
                    liq_pool_sol_leg_pda: ix.accounts[6].0.into(),
                    liq_pool_msol_leg: ix.accounts[7].0.into(),
                    liq_pool_msol_leg_authority: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: RemoveLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::RemoveLiquidity(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [10, 24, 168, 119, 86, 48, 225, 17] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ConfigLpIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: ConfigLpIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::ConfigLp(ix_accounts, de_ix_data))
            },
            [67, 3, 34, 114, 190, 185, 17, 62] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ConfigMarinadeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: ConfigMarinadeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::ConfigMarinade(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [97, 167, 144, 107, 117, 190, 128, 36] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = OrderUnstakeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    msol_mint: ix.accounts[1].0.into(),
                    burn_msol_from: ix.accounts[2].0.into(),
                    burn_msol_authority: ix.accounts[3].0.into(),
                    new_ticket_account: ix.accounts[4].0.into(),
                    clock: ix.accounts[5].0.into(),
                    rent: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: OrderUnstakeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::OrderUnstake(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [62, 198, 214, 193, 213, 159, 108, 210] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = ClaimIxAccounts {
                    state: ix.accounts[0].0.into(),
                    reserve_pda: ix.accounts[1].0.into(),
                    ticket_account: ix.accounts[2].0.into(),
                    transfer_sol_to: ix.accounts[3].0.into(),
                    clock: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                Ok(MarinadeFinanceProgramIx::Claim(ix_accounts))
            },
            [87, 217, 23, 179, 205, 25, 113, 129] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = StakeReserveIxAccounts {
                    state: ix.accounts[0].0.into(),
                    validator_list: ix.accounts[1].0.into(),
                    stake_list: ix.accounts[2].0.into(),
                    validator_vote: ix.accounts[3].0.into(),
                    reserve_pda: ix.accounts[4].0.into(),
                    stake_account: ix.accounts[5].0.into(),
                    stake_deposit_authority: ix.accounts[6].0.into(),
                    rent_payer: ix.accounts[7].0.into(),
                    clock: ix.accounts[8].0.into(),
                    epoch_schedule: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                    stake_history: ix.accounts[11].0.into(),
                    stake_config: ix.accounts[12].0.into(),
                    system_program: ix.accounts[13].0.into(),
                    stake_program: ix.accounts[14].0.into(),
                };
                let de_ix_data: StakeReserveIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::StakeReserve(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [4, 67, 81, 64, 136, 245, 93, 152] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = UpdateActiveIxAccounts {
                    state: ix.accounts[0].0.into(),
                    stake_list: ix.accounts[1].0.into(),
                    stake_account: ix.accounts[2].0.into(),
                    stake_withdraw_authority: ix.accounts[3].0.into(),
                    reserve_pda: ix.accounts[4].0.into(),
                    msol_mint: ix.accounts[5].0.into(),
                    msol_mint_authority: ix.accounts[6].0.into(),
                    treasury_msol_account: ix.accounts[7].0.into(),
                    clock: ix.accounts[8].0.into(),
                    stake_history: ix.accounts[9].0.into(),
                    stake_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    validator_list: ix.accounts[12].0.into(),
                };
                let de_ix_data: UpdateActiveIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::UpdateActive(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [16, 232, 131, 115, 156, 100, 239, 50] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = UpdateDeactivatedIxAccounts {
                    state: ix.accounts[0].0.into(),
                    stake_list: ix.accounts[1].0.into(),
                    stake_account: ix.accounts[2].0.into(),
                    stake_withdraw_authority: ix.accounts[3].0.into(),
                    reserve_pda: ix.accounts[4].0.into(),
                    msol_mint: ix.accounts[5].0.into(),
                    msol_mint_authority: ix.accounts[6].0.into(),
                    treasury_msol_account: ix.accounts[7].0.into(),
                    clock: ix.accounts[8].0.into(),
                    stake_history: ix.accounts[9].0.into(),
                    stake_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    operational_sol_account: ix.accounts[12].0.into(),
                    system_program: ix.accounts[13].0.into(),
                };
                let de_ix_data: UpdateDeactivatedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::UpdateDeactivated(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [165, 158, 229, 97, 168, 220, 187, 225] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = DeactivateStakeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    reserve_pda: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    stake_list: ix.accounts[3].0.into(),
                    stake_account: ix.accounts[4].0.into(),
                    stake_deposit_authority: ix.accounts[5].0.into(),
                    split_stake_account: ix.accounts[6].0.into(),
                    split_stake_rent_payer: ix.accounts[7].0.into(),
                    clock: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    epoch_schedule: ix.accounts[10].0.into(),
                    stake_history: ix.accounts[11].0.into(),
                    system_program: ix.accounts[12].0.into(),
                    stake_program: ix.accounts[13].0.into(),
                };
                let de_ix_data: DeactivateStakeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::DeactivateStake(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [123, 69, 168, 195, 183, 213, 199, 214] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = EmergencyUnstakeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    validator_manager_authority: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    stake_list: ix.accounts[3].0.into(),
                    stake_account: ix.accounts[4].0.into(),
                    stake_deposit_authority: ix.accounts[5].0.into(),
                    clock: ix.accounts[6].0.into(),
                    stake_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: EmergencyUnstakeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::EmergencyUnstake(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [55, 241, 205, 221, 45, 114, 205, 163] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = PartialUnstakeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    validator_manager_authority: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    stake_list: ix.accounts[3].0.into(),
                    stake_account: ix.accounts[4].0.into(),
                    stake_deposit_authority: ix.accounts[5].0.into(),
                    reserve_pda: ix.accounts[6].0.into(),
                    split_stake_account: ix.accounts[7].0.into(),
                    split_stake_rent_payer: ix.accounts[8].0.into(),
                    clock: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                    stake_history: ix.accounts[11].0.into(),
                    system_program: ix.accounts[12].0.into(),
                    stake_program: ix.accounts[13].0.into(),
                };
                let de_ix_data: PartialUnstakeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::PartialUnstake(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [216, 36, 141, 225, 243, 78, 125, 237] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = MergeStakesIxAccounts {
                    state: ix.accounts[0].0.into(),
                    stake_list: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    destination_stake: ix.accounts[3].0.into(),
                    source_stake: ix.accounts[4].0.into(),
                    stake_deposit_authority: ix.accounts[5].0.into(),
                    stake_withdraw_authority: ix.accounts[6].0.into(),
                    operational_sol_account: ix.accounts[7].0.into(),
                    clock: ix.accounts[8].0.into(),
                    stake_history: ix.accounts[9].0.into(),
                    stake_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: MergeStakesIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::MergeStakes(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [212, 82, 51, 160, 228, 80, 116, 35] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = RedelegateIxAccounts {
                    state: ix.accounts[0].0.into(),
                    validator_list: ix.accounts[1].0.into(),
                    stake_list: ix.accounts[2].0.into(),
                    stake_account: ix.accounts[3].0.into(),
                    stake_deposit_authority: ix.accounts[4].0.into(),
                    reserve_pda: ix.accounts[5].0.into(),
                    split_stake_account: ix.accounts[6].0.into(),
                    split_stake_rent_payer: ix.accounts[7].0.into(),
                    dest_validator_account: ix.accounts[8].0.into(),
                    redelegate_stake_account: ix.accounts[9].0.into(),
                    clock: ix.accounts[10].0.into(),
                    stake_history: ix.accounts[11].0.into(),
                    stake_config: ix.accounts[12].0.into(),
                    system_program: ix.accounts[13].0.into(),
                    stake_program: ix.accounts[14].0.into(),
                };
                let de_ix_data: RedelegateIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::Redelegate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [211, 22, 221, 251, 74, 121, 193, 47] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = PauseIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pause_authority: ix.accounts[1].0.into(),
                };
                Ok(MarinadeFinanceProgramIx::Pause(ix_accounts))
            },
            [1, 166, 51, 170, 127, 32, 141, 206] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ResumeIxAccounts {
                    state: ix.accounts[0].0.into(),
                    pause_authority: ix.accounts[1].0.into(),
                };
                Ok(MarinadeFinanceProgramIx::Resume(ix_accounts))
            },
            [211, 85, 184, 65, 183, 177, 233, 217] => {
                check_min_accounts_req(accounts_len, 16)?;
                let ix_accounts = WithdrawStakeAccountIxAccounts {
                    state: ix.accounts[0].0.into(),
                    msol_mint: ix.accounts[1].0.into(),
                    burn_msol_from: ix.accounts[2].0.into(),
                    burn_msol_authority: ix.accounts[3].0.into(),
                    treasury_msol_account: ix.accounts[4].0.into(),
                    validator_list: ix.accounts[5].0.into(),
                    stake_list: ix.accounts[6].0.into(),
                    stake_withdraw_authority: ix.accounts[7].0.into(),
                    stake_deposit_authority: ix.accounts[8].0.into(),
                    stake_account: ix.accounts[9].0.into(),
                    split_stake_account: ix.accounts[10].0.into(),
                    split_stake_rent_payer: ix.accounts[11].0.into(),
                    clock: ix.accounts[12].0.into(),
                    system_program: ix.accounts[13].0.into(),
                    token_program: ix.accounts[14].0.into(),
                    stake_program: ix.accounts[15].0.into(),
                };
                let de_ix_data: WithdrawStakeAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::WithdrawStakeAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [215, 59, 218, 133, 93, 138, 60, 123] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = ReallocValidatorListIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin_authority: ix.accounts[1].0.into(),
                    validator_list: ix.accounts[2].0.into(),
                    rent_funds: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: ReallocValidatorListIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::ReallocValidatorList(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [12, 36, 124, 27, 128, 96, 85, 199] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = ReallocStakeListIxAccounts {
                    state: ix.accounts[0].0.into(),
                    admin_authority: ix.accounts[1].0.into(),
                    stake_list: ix.accounts[2].0.into(),
                    rent_funds: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: ReallocStakeListIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(MarinadeFinanceProgramIx::ReallocStakeList(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
