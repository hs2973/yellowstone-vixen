//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CloseBundledPosition as CloseBundledPositionIxAccounts,
        CloseBundledPositionInstructionArgs as CloseBundledPositionIxData,
        ClosePosition as ClosePositionIxAccounts,
        ClosePositionWithTokenExtensions as ClosePositionWithTokenExtensionsIxAccounts,
        CollectFees as CollectFeesIxAccounts, CollectFeesV2 as CollectFeesV2IxAccounts,
        CollectFeesV2InstructionArgs as CollectFeesV2IxData,
        CollectProtocolFees as CollectProtocolFeesIxAccounts,
        CollectProtocolFeesV2 as CollectProtocolFeesV2IxAccounts,
        CollectProtocolFeesV2InstructionArgs as CollectProtocolFeesV2IxData,
        CollectReward as CollectRewardIxAccounts,
        CollectRewardInstructionArgs as CollectRewardIxData,
        CollectRewardV2 as CollectRewardV2IxAccounts,
        CollectRewardV2InstructionArgs as CollectRewardV2IxData,
        DecreaseLiquidity as DecreaseLiquidityIxAccounts,
        DecreaseLiquidityInstructionArgs as DecreaseLiquidityIxData,
        DecreaseLiquidityV2 as DecreaseLiquidityV2IxAccounts,
        DecreaseLiquidityV2InstructionArgs as DecreaseLiquidityV2IxData,
        DeletePositionBundle as DeletePositionBundleIxAccounts,
        DeleteTokenBadge as DeleteTokenBadgeIxAccounts,
        IncreaseLiquidity as IncreaseLiquidityIxAccounts,
        IncreaseLiquidityInstructionArgs as IncreaseLiquidityIxData,
        IncreaseLiquidityV2 as IncreaseLiquidityV2IxAccounts,
        IncreaseLiquidityV2InstructionArgs as IncreaseLiquidityV2IxData,
        InitializeConfig as InitializeConfigIxAccounts,
        InitializeConfigExtension as InitializeConfigExtensionIxAccounts,
        InitializeConfigInstructionArgs as InitializeConfigIxData,
        InitializeFeeTier as InitializeFeeTierIxAccounts,
        InitializeFeeTierInstructionArgs as InitializeFeeTierIxData,
        InitializePool as InitializePoolIxAccounts,
        InitializePoolInstructionArgs as InitializePoolIxData,
        InitializePoolV2 as InitializePoolV2IxAccounts,
        InitializePoolV2InstructionArgs as InitializePoolV2IxData,
        InitializePositionBundle as InitializePositionBundleIxAccounts,
        InitializePositionBundleWithMetadata as InitializePositionBundleWithMetadataIxAccounts,
        InitializeReward as InitializeRewardIxAccounts,
        InitializeRewardInstructionArgs as InitializeRewardIxData,
        InitializeRewardV2 as InitializeRewardV2IxAccounts,
        InitializeRewardV2InstructionArgs as InitializeRewardV2IxData,
        InitializeTickArray as InitializeTickArrayIxAccounts,
        InitializeTickArrayInstructionArgs as InitializeTickArrayIxData,
        InitializeTokenBadge as InitializeTokenBadgeIxAccounts,
        LockPosition as LockPositionIxAccounts, LockPositionInstructionArgs as LockPositionIxData,
        OpenBundledPosition as OpenBundledPositionIxAccounts,
        OpenBundledPositionInstructionArgs as OpenBundledPositionIxData,
        OpenPosition as OpenPositionIxAccounts, OpenPositionInstructionArgs as OpenPositionIxData,
        OpenPositionWithMetadata as OpenPositionWithMetadataIxAccounts,
        OpenPositionWithMetadataInstructionArgs as OpenPositionWithMetadataIxData,
        OpenPositionWithTokenExtensions as OpenPositionWithTokenExtensionsIxAccounts,
        OpenPositionWithTokenExtensionsInstructionArgs as OpenPositionWithTokenExtensionsIxData,
        SetCollectProtocolFeesAuthority as SetCollectProtocolFeesAuthorityIxAccounts,
        SetConfigExtensionAuthority as SetConfigExtensionAuthorityIxAccounts,
        SetDefaultFeeRate as SetDefaultFeeRateIxAccounts,
        SetDefaultFeeRateInstructionArgs as SetDefaultFeeRateIxData,
        SetDefaultProtocolFeeRate as SetDefaultProtocolFeeRateIxAccounts,
        SetDefaultProtocolFeeRateInstructionArgs as SetDefaultProtocolFeeRateIxData,
        SetFeeAuthority as SetFeeAuthorityIxAccounts, SetFeeRate as SetFeeRateIxAccounts,
        SetFeeRateInstructionArgs as SetFeeRateIxData,
        SetProtocolFeeRate as SetProtocolFeeRateIxAccounts,
        SetProtocolFeeRateInstructionArgs as SetProtocolFeeRateIxData,
        SetRewardAuthority as SetRewardAuthorityIxAccounts,
        SetRewardAuthorityBySuperAuthority as SetRewardAuthorityBySuperAuthorityIxAccounts,
        SetRewardAuthorityBySuperAuthorityInstructionArgs as SetRewardAuthorityBySuperAuthorityIxData,
        SetRewardAuthorityInstructionArgs as SetRewardAuthorityIxData,
        SetRewardEmissions as SetRewardEmissionsIxAccounts,
        SetRewardEmissionsInstructionArgs as SetRewardEmissionsIxData,
        SetRewardEmissionsSuperAuthority as SetRewardEmissionsSuperAuthorityIxAccounts,
        SetRewardEmissionsV2 as SetRewardEmissionsV2IxAccounts,
        SetRewardEmissionsV2InstructionArgs as SetRewardEmissionsV2IxData,
        SetTokenBadgeAuthority as SetTokenBadgeAuthorityIxAccounts, Swap as SwapIxAccounts,
        SwapInstructionArgs as SwapIxData, SwapV2 as SwapV2IxAccounts,
        SwapV2InstructionArgs as SwapV2IxData, TwoHopSwap as TwoHopSwapIxAccounts,
        TwoHopSwapInstructionArgs as TwoHopSwapIxData, TwoHopSwapV2 as TwoHopSwapV2IxAccounts,
        TwoHopSwapV2InstructionArgs as TwoHopSwapV2IxData,
        UpdateFeesAndRewards as UpdateFeesAndRewardsIxAccounts,
    },
    ID,
};

/// Whirlpool Instructions
#[derive(Debug)]
pub enum WhirlpoolProgramIx {
    InitializeConfig(InitializeConfigIxAccounts, InitializeConfigIxData),
    InitializePool(InitializePoolIxAccounts, InitializePoolIxData),
    InitializeTickArray(InitializeTickArrayIxAccounts, InitializeTickArrayIxData),
    InitializeFeeTier(InitializeFeeTierIxAccounts, InitializeFeeTierIxData),
    InitializeReward(InitializeRewardIxAccounts, InitializeRewardIxData),
    SetRewardEmissions(SetRewardEmissionsIxAccounts, SetRewardEmissionsIxData),
    OpenPosition(OpenPositionIxAccounts, OpenPositionIxData),
    OpenPositionWithMetadata(
        OpenPositionWithMetadataIxAccounts,
        OpenPositionWithMetadataIxData,
    ),
    IncreaseLiquidity(IncreaseLiquidityIxAccounts, IncreaseLiquidityIxData),
    DecreaseLiquidity(DecreaseLiquidityIxAccounts, DecreaseLiquidityIxData),
    UpdateFeesAndRewards(UpdateFeesAndRewardsIxAccounts),
    CollectFees(CollectFeesIxAccounts),
    CollectReward(CollectRewardIxAccounts, CollectRewardIxData),
    CollectProtocolFees(CollectProtocolFeesIxAccounts),
    Swap(SwapIxAccounts, SwapIxData),
    ClosePosition(ClosePositionIxAccounts),
    SetDefaultFeeRate(SetDefaultFeeRateIxAccounts, SetDefaultFeeRateIxData),
    SetDefaultProtocolFeeRate(
        SetDefaultProtocolFeeRateIxAccounts,
        SetDefaultProtocolFeeRateIxData,
    ),
    SetFeeRate(SetFeeRateIxAccounts, SetFeeRateIxData),
    SetProtocolFeeRate(SetProtocolFeeRateIxAccounts, SetProtocolFeeRateIxData),
    SetFeeAuthority(SetFeeAuthorityIxAccounts),
    SetCollectProtocolFeesAuthority(SetCollectProtocolFeesAuthorityIxAccounts),
    SetRewardAuthority(SetRewardAuthorityIxAccounts, SetRewardAuthorityIxData),
    SetRewardAuthorityBySuperAuthority(
        SetRewardAuthorityBySuperAuthorityIxAccounts,
        SetRewardAuthorityBySuperAuthorityIxData,
    ),
    SetRewardEmissionsSuperAuthority(SetRewardEmissionsSuperAuthorityIxAccounts),
    TwoHopSwap(TwoHopSwapIxAccounts, TwoHopSwapIxData),
    InitializePositionBundle(InitializePositionBundleIxAccounts),
    InitializePositionBundleWithMetadata(InitializePositionBundleWithMetadataIxAccounts),
    DeletePositionBundle(DeletePositionBundleIxAccounts),
    OpenBundledPosition(OpenBundledPositionIxAccounts, OpenBundledPositionIxData),
    CloseBundledPosition(CloseBundledPositionIxAccounts, CloseBundledPositionIxData),
    OpenPositionWithTokenExtensions(
        OpenPositionWithTokenExtensionsIxAccounts,
        OpenPositionWithTokenExtensionsIxData,
    ),
    ClosePositionWithTokenExtensions(ClosePositionWithTokenExtensionsIxAccounts),
    LockPosition(LockPositionIxAccounts, LockPositionIxData),
    CollectFeesV2(CollectFeesV2IxAccounts, CollectFeesV2IxData),
    CollectProtocolFeesV2(CollectProtocolFeesV2IxAccounts, CollectProtocolFeesV2IxData),
    CollectRewardV2(CollectRewardV2IxAccounts, CollectRewardV2IxData),
    DecreaseLiquidityV2(DecreaseLiquidityV2IxAccounts, DecreaseLiquidityV2IxData),
    IncreaseLiquidityV2(IncreaseLiquidityV2IxAccounts, IncreaseLiquidityV2IxData),
    InitializePoolV2(InitializePoolV2IxAccounts, InitializePoolV2IxData),
    InitializeRewardV2(InitializeRewardV2IxAccounts, InitializeRewardV2IxData),
    SetRewardEmissionsV2(SetRewardEmissionsV2IxAccounts, SetRewardEmissionsV2IxData),
    SwapV2(SwapV2IxAccounts, SwapV2IxData),
    TwoHopSwapV2(TwoHopSwapV2IxAccounts, TwoHopSwapV2IxData),
    InitializeConfigExtension(InitializeConfigExtensionIxAccounts),
    SetConfigExtensionAuthority(SetConfigExtensionAuthorityIxAccounts),
    SetTokenBadgeAuthority(SetTokenBadgeAuthorityIxAccounts),
    InitializeTokenBadge(InitializeTokenBadgeIxAccounts),
    DeleteTokenBadge(DeleteTokenBadgeIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = WhirlpoolProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Whirlpool::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<WhirlpoolProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [208, 127, 21, 1, 194, 190, 196, 70] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = InitializeConfigIxAccounts {
                    config: ix.accounts[0].0.into(),
                    funder: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: InitializeConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializeConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [95, 180, 10, 172, 84, 174, 232, 40] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = InitializePoolIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    token_mint_a: ix.accounts[1].0.into(),
                    token_mint_b: ix.accounts[2].0.into(),
                    funder: ix.accounts[3].0.into(),
                    whirlpool: ix.accounts[4].0.into(),
                    token_vault_a: ix.accounts[5].0.into(),
                    token_vault_b: ix.accounts[6].0.into(),
                    fee_tier: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                };
                let de_ix_data: InitializePoolIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializePool(ix_accounts, de_ix_data))
            },
            [11, 188, 193, 214, 141, 91, 149, 184] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = InitializeTickArrayIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    funder: ix.accounts[1].0.into(),
                    tick_array: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                };
                let de_ix_data: InitializeTickArrayIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializeTickArray(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [183, 74, 156, 160, 112, 2, 42, 30] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeFeeTierIxAccounts {
                    config: ix.accounts[0].0.into(),
                    fee_tier: ix.accounts[1].0.into(),
                    funder: ix.accounts[2].0.into(),
                    fee_authority: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: InitializeFeeTierIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializeFeeTier(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [95, 135, 192, 196, 242, 129, 230, 68] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = InitializeRewardIxAccounts {
                    reward_authority: ix.accounts[0].0.into(),
                    funder: ix.accounts[1].0.into(),
                    whirlpool: ix.accounts[2].0.into(),
                    reward_mint: ix.accounts[3].0.into(),
                    reward_vault: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    rent: ix.accounts[7].0.into(),
                };
                let de_ix_data: InitializeRewardIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializeReward(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [13, 197, 86, 168, 109, 176, 27, 244] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetRewardEmissionsIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    reward_authority: ix.accounts[1].0.into(),
                    reward_vault: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetRewardEmissionsIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetRewardEmissions(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [135, 128, 47, 77, 15, 152, 240, 49] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = OpenPositionIxAccounts {
                    funder: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_mint: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    whirlpool: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    rent: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                };
                let de_ix_data: OpenPositionIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::OpenPosition(ix_accounts, de_ix_data))
            },
            [242, 29, 134, 48, 58, 110, 14, 60] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = OpenPositionWithMetadataIxAccounts {
                    funder: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_mint: ix.accounts[3].0.into(),
                    position_metadata_account: ix.accounts[4].0.into(),
                    position_token_account: ix.accounts[5].0.into(),
                    whirlpool: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    associated_token_program: ix.accounts[10].0.into(),
                    metadata_program: ix.accounts[11].0.into(),
                    metadata_update_auth: ix.accounts[12].0.into(),
                };
                let de_ix_data: OpenPositionWithMetadataIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::OpenPositionWithMetadata(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [46, 156, 243, 118, 13, 205, 251, 178] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = IncreaseLiquidityIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    token_program: ix.accounts[1].0.into(),
                    position_authority: ix.accounts[2].0.into(),
                    position: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    token_owner_account_a: ix.accounts[5].0.into(),
                    token_owner_account_b: ix.accounts[6].0.into(),
                    token_vault_a: ix.accounts[7].0.into(),
                    token_vault_b: ix.accounts[8].0.into(),
                    tick_array_lower: ix.accounts[9].0.into(),
                    tick_array_upper: ix.accounts[10].0.into(),
                };
                let de_ix_data: IncreaseLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::IncreaseLiquidity(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [160, 38, 208, 111, 104, 91, 44, 1] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = DecreaseLiquidityIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    token_program: ix.accounts[1].0.into(),
                    position_authority: ix.accounts[2].0.into(),
                    position: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    token_owner_account_a: ix.accounts[5].0.into(),
                    token_owner_account_b: ix.accounts[6].0.into(),
                    token_vault_a: ix.accounts[7].0.into(),
                    token_vault_b: ix.accounts[8].0.into(),
                    tick_array_lower: ix.accounts[9].0.into(),
                    tick_array_upper: ix.accounts[10].0.into(),
                };
                let de_ix_data: DecreaseLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::DecreaseLiquidity(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [154, 230, 250, 13, 236, 209, 75, 223] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateFeesAndRewardsIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    position: ix.accounts[1].0.into(),
                    tick_array_lower: ix.accounts[2].0.into(),
                    tick_array_upper: ix.accounts[3].0.into(),
                };
                Ok(WhirlpoolProgramIx::UpdateFeesAndRewards(ix_accounts))
            },
            [164, 152, 207, 99, 30, 186, 19, 182] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CollectFeesIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    position_authority: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_token_account: ix.accounts[3].0.into(),
                    token_owner_account_a: ix.accounts[4].0.into(),
                    token_vault_a: ix.accounts[5].0.into(),
                    token_owner_account_b: ix.accounts[6].0.into(),
                    token_vault_b: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                };
                Ok(WhirlpoolProgramIx::CollectFees(ix_accounts))
            },
            [70, 5, 132, 87, 86, 235, 177, 34] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CollectRewardIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    position_authority: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_token_account: ix.accounts[3].0.into(),
                    reward_owner_account: ix.accounts[4].0.into(),
                    reward_vault: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: CollectRewardIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::CollectReward(ix_accounts, de_ix_data))
            },
            [22, 67, 23, 98, 150, 178, 70, 220] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = CollectProtocolFeesIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpool: ix.accounts[1].0.into(),
                    collect_protocol_fees_authority: ix.accounts[2].0.into(),
                    token_vault_a: ix.accounts[3].0.into(),
                    token_vault_b: ix.accounts[4].0.into(),
                    token_destination_a: ix.accounts[5].0.into(),
                    token_destination_b: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                };
                Ok(WhirlpoolProgramIx::CollectProtocolFees(ix_accounts))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = SwapIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    token_authority: ix.accounts[1].0.into(),
                    whirlpool: ix.accounts[2].0.into(),
                    token_owner_account_a: ix.accounts[3].0.into(),
                    token_vault_a: ix.accounts[4].0.into(),
                    token_owner_account_b: ix.accounts[5].0.into(),
                    token_vault_b: ix.accounts[6].0.into(),
                    tick_array0: ix.accounts[7].0.into(),
                    tick_array1: ix.accounts[8].0.into(),
                    tick_array2: ix.accounts[9].0.into(),
                    oracle: ix.accounts[10].0.into(),
                };
                let de_ix_data: SwapIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::Swap(ix_accounts, de_ix_data))
            },
            [123, 134, 81, 0, 49, 68, 98, 98] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = ClosePositionIxAccounts {
                    position_authority: ix.accounts[0].0.into(),
                    receiver: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_mint: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                Ok(WhirlpoolProgramIx::ClosePosition(ix_accounts))
            },
            [118, 215, 214, 157, 182, 229, 208, 228] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetDefaultFeeRateIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    fee_tier: ix.accounts[1].0.into(),
                    fee_authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetDefaultFeeRateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetDefaultFeeRate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [107, 205, 249, 226, 151, 35, 86, 0] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetDefaultProtocolFeeRateIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: SetDefaultProtocolFeeRateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetDefaultProtocolFeeRate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [53, 243, 137, 65, 8, 140, 158, 6] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetFeeRateIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpool: ix.accounts[1].0.into(),
                    fee_authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetFeeRateIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetFeeRate(ix_accounts, de_ix_data))
            },
            [95, 7, 4, 50, 154, 79, 156, 131] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetProtocolFeeRateIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpool: ix.accounts[1].0.into(),
                    fee_authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetProtocolFeeRateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetProtocolFeeRate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [31, 1, 50, 87, 237, 101, 97, 132] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetFeeAuthorityIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                    new_fee_authority: ix.accounts[2].0.into(),
                };
                Ok(WhirlpoolProgramIx::SetFeeAuthority(ix_accounts))
            },
            [34, 150, 93, 244, 139, 225, 233, 67] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetCollectProtocolFeesAuthorityIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    collect_protocol_fees_authority: ix.accounts[1].0.into(),
                    new_collect_protocol_fees_authority: ix.accounts[2].0.into(),
                };
                Ok(WhirlpoolProgramIx::SetCollectProtocolFeesAuthority(
                    ix_accounts,
                ))
            },
            [34, 39, 183, 252, 83, 28, 85, 127] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetRewardAuthorityIxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    reward_authority: ix.accounts[1].0.into(),
                    new_reward_authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetRewardAuthorityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetRewardAuthority(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [240, 154, 201, 198, 148, 93, 56, 25] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = SetRewardAuthorityBySuperAuthorityIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpool: ix.accounts[1].0.into(),
                    reward_emissions_super_authority: ix.accounts[2].0.into(),
                    new_reward_authority: ix.accounts[3].0.into(),
                };
                let de_ix_data: SetRewardAuthorityBySuperAuthorityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetRewardAuthorityBySuperAuthority(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [207, 5, 200, 209, 122, 56, 82, 183] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetRewardEmissionsSuperAuthorityIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    reward_emissions_super_authority: ix.accounts[1].0.into(),
                    new_reward_emissions_super_authority: ix.accounts[2].0.into(),
                };
                Ok(WhirlpoolProgramIx::SetRewardEmissionsSuperAuthority(
                    ix_accounts,
                ))
            },
            [195, 96, 237, 108, 68, 162, 219, 230] => {
                check_min_accounts_req(accounts_len, 20)?;
                let ix_accounts = TwoHopSwapIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    token_authority: ix.accounts[1].0.into(),
                    whirlpool_one: ix.accounts[2].0.into(),
                    whirlpool_two: ix.accounts[3].0.into(),
                    token_owner_account_one_a: ix.accounts[4].0.into(),
                    token_vault_one_a: ix.accounts[5].0.into(),
                    token_owner_account_one_b: ix.accounts[6].0.into(),
                    token_vault_one_b: ix.accounts[7].0.into(),
                    token_owner_account_two_a: ix.accounts[8].0.into(),
                    token_vault_two_a: ix.accounts[9].0.into(),
                    token_owner_account_two_b: ix.accounts[10].0.into(),
                    token_vault_two_b: ix.accounts[11].0.into(),
                    tick_array_one0: ix.accounts[12].0.into(),
                    tick_array_one1: ix.accounts[13].0.into(),
                    tick_array_one2: ix.accounts[14].0.into(),
                    tick_array_two0: ix.accounts[15].0.into(),
                    tick_array_two1: ix.accounts[16].0.into(),
                    tick_array_two2: ix.accounts[17].0.into(),
                    oracle_one: ix.accounts[18].0.into(),
                    oracle_two: ix.accounts[19].0.into(),
                };
                let de_ix_data: TwoHopSwapIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::TwoHopSwap(ix_accounts, de_ix_data))
            },
            [117, 45, 241, 149, 24, 18, 194, 65] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = InitializePositionBundleIxAccounts {
                    position_bundle: ix.accounts[0].0.into(),
                    position_bundle_mint: ix.accounts[1].0.into(),
                    position_bundle_token_account: ix.accounts[2].0.into(),
                    position_bundle_owner: ix.accounts[3].0.into(),
                    funder: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    rent: ix.accounts[7].0.into(),
                    associated_token_program: ix.accounts[8].0.into(),
                };
                Ok(WhirlpoolProgramIx::InitializePositionBundle(ix_accounts))
            },
            [93, 124, 16, 179, 249, 131, 115, 245] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = InitializePositionBundleWithMetadataIxAccounts {
                    position_bundle: ix.accounts[0].0.into(),
                    position_bundle_mint: ix.accounts[1].0.into(),
                    position_bundle_metadata: ix.accounts[2].0.into(),
                    position_bundle_token_account: ix.accounts[3].0.into(),
                    position_bundle_owner: ix.accounts[4].0.into(),
                    funder: ix.accounts[5].0.into(),
                    metadata_update_auth: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                    rent: ix.accounts[9].0.into(),
                    associated_token_program: ix.accounts[10].0.into(),
                    metadata_program: ix.accounts[11].0.into(),
                };
                Ok(WhirlpoolProgramIx::InitializePositionBundleWithMetadata(
                    ix_accounts,
                ))
            },
            [100, 25, 99, 2, 217, 239, 124, 173] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = DeletePositionBundleIxAccounts {
                    position_bundle: ix.accounts[0].0.into(),
                    position_bundle_mint: ix.accounts[1].0.into(),
                    position_bundle_token_account: ix.accounts[2].0.into(),
                    position_bundle_owner: ix.accounts[3].0.into(),
                    receiver: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                Ok(WhirlpoolProgramIx::DeletePositionBundle(ix_accounts))
            },
            [169, 113, 126, 171, 213, 172, 212, 49] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = OpenBundledPositionIxAccounts {
                    bundled_position: ix.accounts[0].0.into(),
                    position_bundle: ix.accounts[1].0.into(),
                    position_bundle_token_account: ix.accounts[2].0.into(),
                    position_bundle_authority: ix.accounts[3].0.into(),
                    whirlpool: ix.accounts[4].0.into(),
                    funder: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    rent: ix.accounts[7].0.into(),
                };
                let de_ix_data: OpenBundledPositionIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::OpenBundledPosition(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [41, 36, 216, 245, 27, 85, 103, 67] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CloseBundledPositionIxAccounts {
                    bundled_position: ix.accounts[0].0.into(),
                    position_bundle: ix.accounts[1].0.into(),
                    position_bundle_token_account: ix.accounts[2].0.into(),
                    position_bundle_authority: ix.accounts[3].0.into(),
                    receiver: ix.accounts[4].0.into(),
                };
                let de_ix_data: CloseBundledPositionIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::CloseBundledPosition(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [212, 47, 95, 92, 114, 102, 131, 250] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = OpenPositionWithTokenExtensionsIxAccounts {
                    funder: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_mint: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    whirlpool: ix.accounts[5].0.into(),
                    token2022_program: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    associated_token_program: ix.accounts[8].0.into(),
                    metadata_update_auth: ix.accounts[9].0.into(),
                };
                let de_ix_data: OpenPositionWithTokenExtensionsIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::OpenPositionWithTokenExtensions(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [1, 182, 135, 59, 155, 25, 99, 223] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = ClosePositionWithTokenExtensionsIxAccounts {
                    position_authority: ix.accounts[0].0.into(),
                    receiver: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_mint: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    token2022_program: ix.accounts[5].0.into(),
                };
                Ok(WhirlpoolProgramIx::ClosePositionWithTokenExtensions(
                    ix_accounts,
                ))
            },
            [227, 62, 2, 252, 247, 10, 171, 185] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = LockPositionIxAccounts {
                    funder: ix.accounts[0].0.into(),
                    position_authority: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_mint: ix.accounts[3].0.into(),
                    position_token_account: ix.accounts[4].0.into(),
                    lock_config: ix.accounts[5].0.into(),
                    whirlpool: ix.accounts[6].0.into(),
                    token2022_program: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: LockPositionIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::LockPosition(ix_accounts, de_ix_data))
            },
            [207, 117, 95, 191, 229, 180, 226, 15] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = CollectFeesV2IxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    position_authority: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_token_account: ix.accounts[3].0.into(),
                    token_mint_a: ix.accounts[4].0.into(),
                    token_mint_b: ix.accounts[5].0.into(),
                    token_owner_account_a: ix.accounts[6].0.into(),
                    token_vault_a: ix.accounts[7].0.into(),
                    token_owner_account_b: ix.accounts[8].0.into(),
                    token_vault_b: ix.accounts[9].0.into(),
                    token_program_a: ix.accounts[10].0.into(),
                    token_program_b: ix.accounts[11].0.into(),
                    memo_program: ix.accounts[12].0.into(),
                };
                let de_ix_data: CollectFeesV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::CollectFeesV2(ix_accounts, de_ix_data))
            },
            [103, 128, 222, 134, 114, 200, 22, 200] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = CollectProtocolFeesV2IxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpool: ix.accounts[1].0.into(),
                    collect_protocol_fees_authority: ix.accounts[2].0.into(),
                    token_mint_a: ix.accounts[3].0.into(),
                    token_mint_b: ix.accounts[4].0.into(),
                    token_vault_a: ix.accounts[5].0.into(),
                    token_vault_b: ix.accounts[6].0.into(),
                    token_destination_a: ix.accounts[7].0.into(),
                    token_destination_b: ix.accounts[8].0.into(),
                    token_program_a: ix.accounts[9].0.into(),
                    token_program_b: ix.accounts[10].0.into(),
                    memo_program: ix.accounts[11].0.into(),
                };
                let de_ix_data: CollectProtocolFeesV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::CollectProtocolFeesV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [177, 107, 37, 180, 160, 19, 49, 209] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CollectRewardV2IxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    position_authority: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    position_token_account: ix.accounts[3].0.into(),
                    reward_owner_account: ix.accounts[4].0.into(),
                    reward_mint: ix.accounts[5].0.into(),
                    reward_vault: ix.accounts[6].0.into(),
                    reward_token_program: ix.accounts[7].0.into(),
                    memo_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: CollectRewardV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::CollectRewardV2(ix_accounts, de_ix_data))
            },
            [58, 127, 188, 62, 79, 82, 196, 96] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = DecreaseLiquidityV2IxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    token_program_a: ix.accounts[1].0.into(),
                    token_program_b: ix.accounts[2].0.into(),
                    memo_program: ix.accounts[3].0.into(),
                    position_authority: ix.accounts[4].0.into(),
                    position: ix.accounts[5].0.into(),
                    position_token_account: ix.accounts[6].0.into(),
                    token_mint_a: ix.accounts[7].0.into(),
                    token_mint_b: ix.accounts[8].0.into(),
                    token_owner_account_a: ix.accounts[9].0.into(),
                    token_owner_account_b: ix.accounts[10].0.into(),
                    token_vault_a: ix.accounts[11].0.into(),
                    token_vault_b: ix.accounts[12].0.into(),
                    tick_array_lower: ix.accounts[13].0.into(),
                    tick_array_upper: ix.accounts[14].0.into(),
                };
                let de_ix_data: DecreaseLiquidityV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::DecreaseLiquidityV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [133, 29, 89, 223, 69, 238, 176, 10] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = IncreaseLiquidityV2IxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    token_program_a: ix.accounts[1].0.into(),
                    token_program_b: ix.accounts[2].0.into(),
                    memo_program: ix.accounts[3].0.into(),
                    position_authority: ix.accounts[4].0.into(),
                    position: ix.accounts[5].0.into(),
                    position_token_account: ix.accounts[6].0.into(),
                    token_mint_a: ix.accounts[7].0.into(),
                    token_mint_b: ix.accounts[8].0.into(),
                    token_owner_account_a: ix.accounts[9].0.into(),
                    token_owner_account_b: ix.accounts[10].0.into(),
                    token_vault_a: ix.accounts[11].0.into(),
                    token_vault_b: ix.accounts[12].0.into(),
                    tick_array_lower: ix.accounts[13].0.into(),
                    tick_array_upper: ix.accounts[14].0.into(),
                };
                let de_ix_data: IncreaseLiquidityV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::IncreaseLiquidityV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [207, 45, 87, 242, 27, 63, 204, 67] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = InitializePoolV2IxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    token_mint_a: ix.accounts[1].0.into(),
                    token_mint_b: ix.accounts[2].0.into(),
                    token_badge_a: ix.accounts[3].0.into(),
                    token_badge_b: ix.accounts[4].0.into(),
                    funder: ix.accounts[5].0.into(),
                    whirlpool: ix.accounts[6].0.into(),
                    token_vault_a: ix.accounts[7].0.into(),
                    token_vault_b: ix.accounts[8].0.into(),
                    fee_tier: ix.accounts[9].0.into(),
                    token_program_a: ix.accounts[10].0.into(),
                    token_program_b: ix.accounts[11].0.into(),
                    system_program: ix.accounts[12].0.into(),
                    rent: ix.accounts[13].0.into(),
                };
                let de_ix_data: InitializePoolV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializePoolV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [91, 1, 77, 50, 235, 229, 133, 49] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = InitializeRewardV2IxAccounts {
                    reward_authority: ix.accounts[0].0.into(),
                    funder: ix.accounts[1].0.into(),
                    whirlpool: ix.accounts[2].0.into(),
                    reward_mint: ix.accounts[3].0.into(),
                    reward_token_badge: ix.accounts[4].0.into(),
                    reward_vault: ix.accounts[5].0.into(),
                    reward_token_program: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    rent: ix.accounts[8].0.into(),
                };
                let de_ix_data: InitializeRewardV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::InitializeRewardV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [114, 228, 72, 32, 193, 48, 160, 102] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetRewardEmissionsV2IxAccounts {
                    whirlpool: ix.accounts[0].0.into(),
                    reward_authority: ix.accounts[1].0.into(),
                    reward_vault: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetRewardEmissionsV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SetRewardEmissionsV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [43, 4, 237, 11, 26, 201, 30, 98] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = SwapV2IxAccounts {
                    token_program_a: ix.accounts[0].0.into(),
                    token_program_b: ix.accounts[1].0.into(),
                    memo_program: ix.accounts[2].0.into(),
                    token_authority: ix.accounts[3].0.into(),
                    whirlpool: ix.accounts[4].0.into(),
                    token_mint_a: ix.accounts[5].0.into(),
                    token_mint_b: ix.accounts[6].0.into(),
                    token_owner_account_a: ix.accounts[7].0.into(),
                    token_vault_a: ix.accounts[8].0.into(),
                    token_owner_account_b: ix.accounts[9].0.into(),
                    token_vault_b: ix.accounts[10].0.into(),
                    tick_array0: ix.accounts[11].0.into(),
                    tick_array1: ix.accounts[12].0.into(),
                    tick_array2: ix.accounts[13].0.into(),
                    oracle: ix.accounts[14].0.into(),
                };
                let de_ix_data: SwapV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::SwapV2(ix_accounts, de_ix_data))
            },
            [186, 143, 209, 29, 254, 2, 194, 117] => {
                check_min_accounts_req(accounts_len, 24)?;
                let ix_accounts = TwoHopSwapV2IxAccounts {
                    whirlpool_one: ix.accounts[0].0.into(),
                    whirlpool_two: ix.accounts[1].0.into(),
                    token_mint_input: ix.accounts[2].0.into(),
                    token_mint_intermediate: ix.accounts[3].0.into(),
                    token_mint_output: ix.accounts[4].0.into(),
                    token_program_input: ix.accounts[5].0.into(),
                    token_program_intermediate: ix.accounts[6].0.into(),
                    token_program_output: ix.accounts[7].0.into(),
                    token_owner_account_input: ix.accounts[8].0.into(),
                    token_vault_one_input: ix.accounts[9].0.into(),
                    token_vault_one_intermediate: ix.accounts[10].0.into(),
                    token_vault_two_intermediate: ix.accounts[11].0.into(),
                    token_vault_two_output: ix.accounts[12].0.into(),
                    token_owner_account_output: ix.accounts[13].0.into(),
                    token_authority: ix.accounts[14].0.into(),
                    tick_array_one0: ix.accounts[15].0.into(),
                    tick_array_one1: ix.accounts[16].0.into(),
                    tick_array_one2: ix.accounts[17].0.into(),
                    tick_array_two0: ix.accounts[18].0.into(),
                    tick_array_two1: ix.accounts[19].0.into(),
                    tick_array_two2: ix.accounts[20].0.into(),
                    oracle_one: ix.accounts[21].0.into(),
                    oracle_two: ix.accounts[22].0.into(),
                    memo_program: ix.accounts[23].0.into(),
                };
                let de_ix_data: TwoHopSwapV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(WhirlpoolProgramIx::TwoHopSwapV2(ix_accounts, de_ix_data))
            },
            [55, 9, 53, 9, 114, 57, 209, 52] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = InitializeConfigExtensionIxAccounts {
                    config: ix.accounts[0].0.into(),
                    config_extension: ix.accounts[1].0.into(),
                    funder: ix.accounts[2].0.into(),
                    fee_authority: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                Ok(WhirlpoolProgramIx::InitializeConfigExtension(ix_accounts))
            },
            [44, 94, 241, 116, 24, 188, 60, 143] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = SetConfigExtensionAuthorityIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpools_config_extension: ix.accounts[1].0.into(),
                    config_extension_authority: ix.accounts[2].0.into(),
                    new_config_extension_authority: ix.accounts[3].0.into(),
                };
                Ok(WhirlpoolProgramIx::SetConfigExtensionAuthority(ix_accounts))
            },
            [207, 202, 4, 32, 205, 79, 13, 178] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = SetTokenBadgeAuthorityIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpools_config_extension: ix.accounts[1].0.into(),
                    config_extension_authority: ix.accounts[2].0.into(),
                    new_token_badge_authority: ix.accounts[3].0.into(),
                };
                Ok(WhirlpoolProgramIx::SetTokenBadgeAuthority(ix_accounts))
            },
            [253, 77, 205, 95, 27, 224, 89, 223] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = InitializeTokenBadgeIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpools_config_extension: ix.accounts[1].0.into(),
                    token_badge_authority: ix.accounts[2].0.into(),
                    token_mint: ix.accounts[3].0.into(),
                    token_badge: ix.accounts[4].0.into(),
                    funder: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                };
                Ok(WhirlpoolProgramIx::InitializeTokenBadge(ix_accounts))
            },
            [53, 146, 68, 8, 18, 117, 17, 185] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = DeleteTokenBadgeIxAccounts {
                    whirlpools_config: ix.accounts[0].0.into(),
                    whirlpools_config_extension: ix.accounts[1].0.into(),
                    token_badge_authority: ix.accounts[2].0.into(),
                    token_mint: ix.accounts[3].0.into(),
                    token_badge: ix.accounts[4].0.into(),
                    receiver: ix.accounts[5].0.into(),
                };
                Ok(WhirlpoolProgramIx::DeleteTokenBadge(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
