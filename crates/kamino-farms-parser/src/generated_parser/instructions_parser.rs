//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        AddRewards as AddRewardsIxAccounts, AddRewardsInstructionArgs as AddRewardsIxData,
        DepositToFarmVault as DepositToFarmVaultIxAccounts,
        DepositToFarmVaultInstructionArgs as DepositToFarmVaultIxData,
        HarvestReward as HarvestRewardIxAccounts,
        HarvestRewardInstructionArgs as HarvestRewardIxData,
        IdlMissingTypes as IdlMissingTypesIxAccounts,
        IdlMissingTypesInstructionArgs as IdlMissingTypesIxData,
        InitializeFarm as InitializeFarmIxAccounts,
        InitializeFarmDelegated as InitializeFarmDelegatedIxAccounts,
        InitializeGlobalConfig as InitializeGlobalConfigIxAccounts,
        InitializeReward as InitializeRewardIxAccounts, InitializeUser as InitializeUserIxAccounts,
        RefreshFarm as RefreshFarmIxAccounts, RefreshUserState as RefreshUserStateIxAccounts,
        RewardUserOnce as RewardUserOnceIxAccounts,
        RewardUserOnceInstructionArgs as RewardUserOnceIxData,
        SetStakeDelegated as SetStakeDelegatedIxAccounts,
        SetStakeDelegatedInstructionArgs as SetStakeDelegatedIxData, Stake as StakeIxAccounts,
        StakeInstructionArgs as StakeIxData, TransferOwnership as TransferOwnershipIxAccounts,
        TransferOwnershipInstructionArgs as TransferOwnershipIxData, Unstake as UnstakeIxAccounts,
        UnstakeInstructionArgs as UnstakeIxData, UpdateFarmAdmin as UpdateFarmAdminIxAccounts,
        UpdateFarmConfig as UpdateFarmConfigIxAccounts,
        UpdateFarmConfigInstructionArgs as UpdateFarmConfigIxData,
        UpdateGlobalConfig as UpdateGlobalConfigIxAccounts,
        UpdateGlobalConfigAdmin as UpdateGlobalConfigAdminIxAccounts,
        UpdateGlobalConfigInstructionArgs as UpdateGlobalConfigIxData,
        WithdrawFromFarmVault as WithdrawFromFarmVaultIxAccounts,
        WithdrawFromFarmVaultInstructionArgs as WithdrawFromFarmVaultIxData,
        WithdrawReward as WithdrawRewardIxAccounts,
        WithdrawRewardInstructionArgs as WithdrawRewardIxData,
        WithdrawSlashedAmount as WithdrawSlashedAmountIxAccounts,
        WithdrawTreasury as WithdrawTreasuryIxAccounts,
        WithdrawTreasuryInstructionArgs as WithdrawTreasuryIxData,
        WithdrawUnstakedDeposits as WithdrawUnstakedDepositsIxAccounts,
    },
    ID,
};

/// Farms Instructions
#[derive(Debug)]
pub enum FarmsProgramIx {
    InitializeGlobalConfig(InitializeGlobalConfigIxAccounts),
    UpdateGlobalConfig(UpdateGlobalConfigIxAccounts, UpdateGlobalConfigIxData),
    InitializeFarm(InitializeFarmIxAccounts),
    InitializeFarmDelegated(InitializeFarmDelegatedIxAccounts),
    InitializeReward(InitializeRewardIxAccounts),
    AddRewards(AddRewardsIxAccounts, AddRewardsIxData),
    UpdateFarmConfig(UpdateFarmConfigIxAccounts, UpdateFarmConfigIxData),
    InitializeUser(InitializeUserIxAccounts),
    TransferOwnership(TransferOwnershipIxAccounts, TransferOwnershipIxData),
    RewardUserOnce(RewardUserOnceIxAccounts, RewardUserOnceIxData),
    RefreshFarm(RefreshFarmIxAccounts),
    Stake(StakeIxAccounts, StakeIxData),
    SetStakeDelegated(SetStakeDelegatedIxAccounts, SetStakeDelegatedIxData),
    HarvestReward(HarvestRewardIxAccounts, HarvestRewardIxData),
    Unstake(UnstakeIxAccounts, UnstakeIxData),
    RefreshUserState(RefreshUserStateIxAccounts),
    WithdrawUnstakedDeposits(WithdrawUnstakedDepositsIxAccounts),
    WithdrawTreasury(WithdrawTreasuryIxAccounts, WithdrawTreasuryIxData),
    DepositToFarmVault(DepositToFarmVaultIxAccounts, DepositToFarmVaultIxData),
    WithdrawFromFarmVault(WithdrawFromFarmVaultIxAccounts, WithdrawFromFarmVaultIxData),
    WithdrawSlashedAmount(WithdrawSlashedAmountIxAccounts),
    UpdateFarmAdmin(UpdateFarmAdminIxAccounts),
    UpdateGlobalConfigAdmin(UpdateGlobalConfigAdminIxAccounts),
    WithdrawReward(WithdrawRewardIxAccounts, WithdrawRewardIxData),
    IdlMissingTypes(IdlMissingTypesIxAccounts, IdlMissingTypesIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = FarmsProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Farms::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<FarmsProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [113, 216, 122, 131, 225, 209, 22, 55] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = InitializeGlobalConfigIxAccounts {
                    global_admin: ix.accounts[0].0.into(),
                    global_config: ix.accounts[1].0.into(),
                    treasury_vaults_authority: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                };
                Ok(FarmsProgramIx::InitializeGlobalConfig(ix_accounts))
            },
            [164, 84, 130, 189, 111, 58, 250, 200] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateGlobalConfigIxAccounts {
                    global_admin: ix.accounts[0].0.into(),
                    global_config: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateGlobalConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::UpdateGlobalConfig(ix_accounts, de_ix_data))
            },
            [252, 28, 185, 172, 244, 74, 117, 165] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = InitializeFarmIxAccounts {
                    farm_admin: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                    global_config: ix.accounts[2].0.into(),
                    farm_vault: ix.accounts[3].0.into(),
                    farm_vaults_authority: ix.accounts[4].0.into(),
                    token_mint: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    rent: ix.accounts[8].0.into(),
                };
                Ok(FarmsProgramIx::InitializeFarm(ix_accounts))
            },
            [250, 84, 101, 25, 51, 77, 204, 91] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = InitializeFarmDelegatedIxAccounts {
                    farm_admin: ix.accounts[0].0.into(),
                    farm_delegate: ix.accounts[1].0.into(),
                    farm_state: ix.accounts[2].0.into(),
                    global_config: ix.accounts[3].0.into(),
                    farm_vaults_authority: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                    rent: ix.accounts[6].0.into(),
                };
                Ok(FarmsProgramIx::InitializeFarmDelegated(ix_accounts))
            },
            [95, 135, 192, 196, 242, 129, 230, 68] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = InitializeRewardIxAccounts {
                    farm_admin: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                    global_config: ix.accounts[2].0.into(),
                    reward_mint: ix.accounts[3].0.into(),
                    reward_vault: ix.accounts[4].0.into(),
                    reward_treasury_vault: ix.accounts[5].0.into(),
                    farm_vaults_authority: ix.accounts[6].0.into(),
                    treasury_vaults_authority: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    rent: ix.accounts[10].0.into(),
                };
                Ok(FarmsProgramIx::InitializeReward(ix_accounts))
            },
            [111, 17, 185, 250, 60, 122, 38, 254] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = InitializeUserIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    owner: ix.accounts[2].0.into(),
                    delegatee: ix.accounts[3].0.into(),
                    user_state: ix.accounts[4].0.into(),
                    farm_state: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    rent: ix.accounts[7].0.into(),
                };
                Ok(FarmsProgramIx::InitializeUser(ix_accounts))
            },
            [65, 177, 215, 73, 53, 45, 99, 47] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = TransferOwnershipIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    user_state: ix.accounts[1].0.into(),
                };
                let de_ix_data: TransferOwnershipIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::TransferOwnership(ix_accounts, de_ix_data))
            },
            [219, 137, 57, 22, 94, 186, 96, 114] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = RewardUserOnceIxAccounts {
                    farm_admin: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                    user_state: ix.accounts[2].0.into(),
                };
                let de_ix_data: RewardUserOnceIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::RewardUserOnce(ix_accounts, de_ix_data))
            },
            [73, 171, 184, 75, 30, 56, 198, 223] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SetStakeDelegatedIxAccounts {
                    delegate_authority: ix.accounts[0].0.into(),
                    user_state: ix.accounts[1].0.into(),
                    farm_state: ix.accounts[2].0.into(),
                };
                let de_ix_data: SetStakeDelegatedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::SetStakeDelegated(ix_accounts, de_ix_data))
            },
            [36, 102, 187, 49, 220, 36, 132, 67] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = WithdrawUnstakedDepositsIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    user_state: ix.accounts[1].0.into(),
                    farm_state: ix.accounts[2].0.into(),
                    user_ata: ix.accounts[3].0.into(),
                    farm_vault: ix.accounts[4].0.into(),
                    farm_vaults_authority: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                Ok(FarmsProgramIx::WithdrawUnstakedDeposits(ix_accounts))
            },
            [40, 63, 122, 158, 144, 216, 83, 96] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = WithdrawTreasuryIxAccounts {
                    global_admin: ix.accounts[0].0.into(),
                    global_config: ix.accounts[1].0.into(),
                    reward_mint: ix.accounts[2].0.into(),
                    reward_treasury_vault: ix.accounts[3].0.into(),
                    treasury_vault_authority: ix.accounts[4].0.into(),
                    withdraw_destination_token_account: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                let de_ix_data: WithdrawTreasuryIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::WithdrawTreasury(ix_accounts, de_ix_data))
            },
            [131, 166, 64, 94, 108, 213, 114, 183] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = DepositToFarmVaultIxAccounts {
                    depositor: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                    farm_vault: ix.accounts[2].0.into(),
                    depositor_ata: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: DepositToFarmVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::DepositToFarmVault(ix_accounts, de_ix_data))
            },
            [22, 82, 128, 250, 86, 79, 124, 78] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = WithdrawFromFarmVaultIxAccounts {
                    withdraw_authority: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                    withdrawer_token_account: ix.accounts[2].0.into(),
                    farm_vault: ix.accounts[3].0.into(),
                    farm_vaults_authority: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: WithdrawFromFarmVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::WithdrawFromFarmVault(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [202, 217, 67, 74, 172, 22, 140, 216] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = WithdrawSlashedAmountIxAccounts {
                    crank: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                    slashed_amount_spill_address: ix.accounts[2].0.into(),
                    farm_vault: ix.accounts[3].0.into(),
                    farm_vaults_authority: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                Ok(FarmsProgramIx::WithdrawSlashedAmount(ix_accounts))
            },
            [20, 37, 136, 19, 122, 239, 36, 130] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateFarmAdminIxAccounts {
                    pending_farm_admin: ix.accounts[0].0.into(),
                    farm_state: ix.accounts[1].0.into(),
                };
                Ok(FarmsProgramIx::UpdateFarmAdmin(ix_accounts))
            },
            [184, 87, 23, 193, 156, 238, 175, 119] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateGlobalConfigAdminIxAccounts {
                    pending_global_admin: ix.accounts[0].0.into(),
                    global_config: ix.accounts[1].0.into(),
                };
                Ok(FarmsProgramIx::UpdateGlobalConfigAdmin(ix_accounts))
            },
            [130, 80, 38, 153, 80, 212, 182, 253] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = IdlMissingTypesIxAccounts {
                    global_admin: ix.accounts[0].0.into(),
                    global_config: ix.accounts[1].0.into(),
                };
                let de_ix_data: IdlMissingTypesIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(FarmsProgramIx::IdlMissingTypes(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
