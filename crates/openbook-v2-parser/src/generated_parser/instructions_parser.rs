//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CancelAllAndPlaceOrders as CancelAllAndPlaceOrdersIxAccounts,
        CancelAllAndPlaceOrdersInstructionArgs as CancelAllAndPlaceOrdersIxData,
        CancelAllOrders as CancelAllOrdersIxAccounts,
        CancelAllOrdersInstructionArgs as CancelAllOrdersIxData,
        CancelOrder as CancelOrderIxAccounts,
        CancelOrderByClientOrderId as CancelOrderByClientOrderIdIxAccounts,
        CancelOrderByClientOrderIdInstructionArgs as CancelOrderByClientOrderIdIxData,
        CancelOrderInstructionArgs as CancelOrderIxData, CloseMarket as CloseMarketIxAccounts,
        CloseOpenOrdersAccount as CloseOpenOrdersAccountIxAccounts,
        CloseOpenOrdersIndexer as CloseOpenOrdersIndexerIxAccounts,
        ConsumeEvents as ConsumeEventsIxAccounts,
        ConsumeEventsInstructionArgs as ConsumeEventsIxData,
        ConsumeGivenEvents as ConsumeGivenEventsIxAccounts,
        ConsumeGivenEventsInstructionArgs as ConsumeGivenEventsIxData,
        CreateMarket as CreateMarketIxAccounts, CreateMarketInstructionArgs as CreateMarketIxData,
        CreateOpenOrdersAccount as CreateOpenOrdersAccountIxAccounts,
        CreateOpenOrdersAccountInstructionArgs as CreateOpenOrdersAccountIxData,
        CreateOpenOrdersIndexer as CreateOpenOrdersIndexerIxAccounts, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData, EditOrder as EditOrderIxAccounts,
        EditOrderInstructionArgs as EditOrderIxData, EditOrderPegged as EditOrderPeggedIxAccounts,
        EditOrderPeggedInstructionArgs as EditOrderPeggedIxData,
        PlaceOrder as PlaceOrderIxAccounts, PlaceOrderInstructionArgs as PlaceOrderIxData,
        PlaceOrderPegged as PlaceOrderPeggedIxAccounts,
        PlaceOrderPeggedInstructionArgs as PlaceOrderPeggedIxData,
        PlaceOrders as PlaceOrdersIxAccounts, PlaceOrdersInstructionArgs as PlaceOrdersIxData,
        PlaceTakeOrder as PlaceTakeOrderIxAccounts,
        PlaceTakeOrderInstructionArgs as PlaceTakeOrderIxData,
        PruneOrders as PruneOrdersIxAccounts, PruneOrdersInstructionArgs as PruneOrdersIxData,
        Refill as RefillIxAccounts, RefillInstructionArgs as RefillIxData,
        SetDelegate as SetDelegateIxAccounts, SetMarketExpired as SetMarketExpiredIxAccounts,
        SettleFunds as SettleFundsIxAccounts, SettleFundsExpired as SettleFundsExpiredIxAccounts,
        StubOracleClose as StubOracleCloseIxAccounts,
        StubOracleCreate as StubOracleCreateIxAccounts,
        StubOracleCreateInstructionArgs as StubOracleCreateIxData,
        StubOracleSet as StubOracleSetIxAccounts,
        StubOracleSetInstructionArgs as StubOracleSetIxData, SweepFees as SweepFeesIxAccounts,
    },
    ID,
};

/// OpenbookV2 Instructions
#[allow(clippy::large_enum_variant)]
#[derive(Debug)]
pub enum OpenbookV2ProgramIx {
    CreateMarket(CreateMarketIxAccounts, CreateMarketIxData),
    CloseMarket(CloseMarketIxAccounts),
    CreateOpenOrdersIndexer(CreateOpenOrdersIndexerIxAccounts),
    CloseOpenOrdersIndexer(CloseOpenOrdersIndexerIxAccounts),
    CreateOpenOrdersAccount(
        CreateOpenOrdersAccountIxAccounts,
        CreateOpenOrdersAccountIxData,
    ),
    CloseOpenOrdersAccount(CloseOpenOrdersAccountIxAccounts),
    PlaceOrder(PlaceOrderIxAccounts, PlaceOrderIxData),
    EditOrder(EditOrderIxAccounts, EditOrderIxData),
    EditOrderPegged(EditOrderPeggedIxAccounts, EditOrderPeggedIxData),
    PlaceOrders(PlaceOrdersIxAccounts, PlaceOrdersIxData),
    CancelAllAndPlaceOrders(
        CancelAllAndPlaceOrdersIxAccounts,
        CancelAllAndPlaceOrdersIxData,
    ),
    PlaceOrderPegged(PlaceOrderPeggedIxAccounts, PlaceOrderPeggedIxData),
    PlaceTakeOrder(PlaceTakeOrderIxAccounts, PlaceTakeOrderIxData),
    ConsumeEvents(ConsumeEventsIxAccounts, ConsumeEventsIxData),
    ConsumeGivenEvents(ConsumeGivenEventsIxAccounts, ConsumeGivenEventsIxData),
    CancelOrder(CancelOrderIxAccounts, CancelOrderIxData),
    CancelOrderByClientOrderId(
        CancelOrderByClientOrderIdIxAccounts,
        CancelOrderByClientOrderIdIxData,
    ),
    CancelAllOrders(CancelAllOrdersIxAccounts, CancelAllOrdersIxData),
    Deposit(DepositIxAccounts, DepositIxData),
    Refill(RefillIxAccounts, RefillIxData),
    SettleFunds(SettleFundsIxAccounts),
    SettleFundsExpired(SettleFundsExpiredIxAccounts),
    SweepFees(SweepFeesIxAccounts),
    SetDelegate(SetDelegateIxAccounts),
    SetMarketExpired(SetMarketExpiredIxAccounts),
    PruneOrders(PruneOrdersIxAccounts, PruneOrdersIxData),
    StubOracleCreate(StubOracleCreateIxAccounts, StubOracleCreateIxData),
    StubOracleClose(StubOracleCloseIxAccounts),
    StubOracleSet(StubOracleSetIxAccounts, StubOracleSetIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = OpenbookV2ProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "OpenbookV2::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<OpenbookV2ProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [88, 154, 248, 186, 48, 14, 123, 244] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CloseMarketIxAccounts {
                    close_market_admin: ix.accounts[0].0.into(),
                    market: ix.accounts[1].0.into(),
                    bids: ix.accounts[2].0.into(),
                    asks: ix.accounts[3].0.into(),
                    event_heap: ix.accounts[4].0.into(),
                    sol_destination: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                Ok(OpenbookV2ProgramIx::CloseMarket(ix_accounts))
            },
            [64, 64, 153, 255, 217, 71, 249, 133] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = CreateOpenOrdersIndexerIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    open_orders_indexer: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                };
                Ok(OpenbookV2ProgramIx::CreateOpenOrdersIndexer(ix_accounts))
            },
            [103, 249, 229, 231, 247, 253, 197, 136] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = CloseOpenOrdersIndexerIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    open_orders_indexer: ix.accounts[1].0.into(),
                    sol_destination: ix.accounts[2].0.into(),
                    token_program: ix.accounts[3].0.into(),
                };
                Ok(OpenbookV2ProgramIx::CloseOpenOrdersIndexer(ix_accounts))
            },
            [176, 74, 115, 210, 54, 179, 91, 103] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CloseOpenOrdersAccountIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    open_orders_indexer: ix.accounts[1].0.into(),
                    open_orders_account: ix.accounts[2].0.into(),
                    sol_destination: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                Ok(OpenbookV2ProgramIx::CloseOpenOrdersAccount(ix_accounts))
            },
            [95, 129, 237, 240, 8, 49, 223, 132] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CancelOrderIxAccounts {
                    signer: ix.accounts[0].0.into(),
                    open_orders_account: ix.accounts[1].0.into(),
                    market: ix.accounts[2].0.into(),
                    bids: ix.accounts[3].0.into(),
                    asks: ix.accounts[4].0.into(),
                };
                let de_ix_data: CancelOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::CancelOrder(ix_accounts, de_ix_data))
            },
            [115, 178, 201, 8, 175, 183, 123, 119] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CancelOrderByClientOrderIdIxAccounts {
                    signer: ix.accounts[0].0.into(),
                    open_orders_account: ix.accounts[1].0.into(),
                    market: ix.accounts[2].0.into(),
                    bids: ix.accounts[3].0.into(),
                    asks: ix.accounts[4].0.into(),
                };
                let de_ix_data: CancelOrderByClientOrderIdIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::CancelOrderByClientOrderId(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [196, 83, 243, 171, 17, 100, 160, 143] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CancelAllOrdersIxAccounts {
                    signer: ix.accounts[0].0.into(),
                    open_orders_account: ix.accounts[1].0.into(),
                    market: ix.accounts[2].0.into(),
                    bids: ix.accounts[3].0.into(),
                    asks: ix.accounts[4].0.into(),
                };
                let de_ix_data: CancelAllOrdersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::CancelAllOrders(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = DepositIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    user_base_account: ix.accounts[1].0.into(),
                    user_quote_account: ix.accounts[2].0.into(),
                    open_orders_account: ix.accounts[3].0.into(),
                    market: ix.accounts[4].0.into(),
                    market_base_vault: ix.accounts[5].0.into(),
                    market_quote_vault: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: DepositIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [128, 207, 142, 11, 54, 232, 38, 201] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = RefillIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    user_base_account: ix.accounts[1].0.into(),
                    user_quote_account: ix.accounts[2].0.into(),
                    open_orders_account: ix.accounts[3].0.into(),
                    market: ix.accounts[4].0.into(),
                    market_base_vault: ix.accounts[5].0.into(),
                    market_quote_vault: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: RefillIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::Refill(ix_accounts, de_ix_data))
            },
            [175, 225, 98, 71, 118, 66, 34, 148] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = SweepFeesIxAccounts {
                    collect_fee_admin: ix.accounts[0].0.into(),
                    market: ix.accounts[1].0.into(),
                    market_authority: ix.accounts[2].0.into(),
                    market_quote_vault: ix.accounts[3].0.into(),
                    token_receiver_account: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                Ok(OpenbookV2ProgramIx::SweepFees(ix_accounts))
            },
            [219, 82, 219, 236, 60, 115, 197, 64] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetMarketExpiredIxAccounts {
                    close_market_admin: ix.accounts[0].0.into(),
                    market: ix.accounts[1].0.into(),
                };
                Ok(OpenbookV2ProgramIx::SetMarketExpired(ix_accounts))
            },
            [27, 213, 159, 191, 12, 116, 112, 121] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = PruneOrdersIxAccounts {
                    close_market_admin: ix.accounts[0].0.into(),
                    open_orders_account: ix.accounts[1].0.into(),
                    market: ix.accounts[2].0.into(),
                    bids: ix.accounts[3].0.into(),
                    asks: ix.accounts[4].0.into(),
                };
                let de_ix_data: PruneOrdersIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::PruneOrders(ix_accounts, de_ix_data))
            },
            [172, 63, 101, 83, 141, 76, 199, 216] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = StubOracleCreateIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    oracle: ix.accounts[2].0.into(),
                    mint: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: StubOracleCreateIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::StubOracleCreate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [92, 137, 45, 3, 45, 60, 117, 224] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = StubOracleCloseIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    oracle: ix.accounts[1].0.into(),
                    sol_destination: ix.accounts[2].0.into(),
                    token_program: ix.accounts[3].0.into(),
                };
                Ok(OpenbookV2ProgramIx::StubOracleClose(ix_accounts))
            },
            [109, 198, 79, 121, 65, 202, 161, 142] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = StubOracleSetIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    oracle: ix.accounts[1].0.into(),
                };
                let de_ix_data: StubOracleSetIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(OpenbookV2ProgramIx::StubOracleSet(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
