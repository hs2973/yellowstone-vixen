//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        Authorize as AuthorizeIxAccounts, AuthorizeChecked as AuthorizeCheckedIxAccounts,
        AuthorizeCheckedInstructionArgs as AuthorizeCheckedIxData,
        AuthorizeCheckedWithSeed as AuthorizeCheckedWithSeedIxAccounts,
        AuthorizeCheckedWithSeedInstructionArgs as AuthorizeCheckedWithSeedIxData,
        AuthorizeInstructionArgs as AuthorizeIxData,
        AuthorizeWithSeed as AuthorizeWithSeedIxAccounts,
        AuthorizeWithSeedInstructionArgs as AuthorizeWithSeedIxData,
        Deactivate as DeactivateIxAccounts, DeactivateDelinquent as DeactivateDelinquentIxAccounts,
        DelegateStake as DelegateStakeIxAccounts,
        GetMinimumDelegation as GetMinimumDelegationIxAccounts, Initialize as InitializeIxAccounts,
        InitializeChecked as InitializeCheckedIxAccounts,
        InitializeInstructionArgs as InitializeIxData, Merge as MergeIxAccounts,
        SetLockup as SetLockupIxAccounts, SetLockupChecked as SetLockupCheckedIxAccounts,
        SetLockupCheckedInstructionArgs as SetLockupCheckedIxData,
        SetLockupInstructionArgs as SetLockupIxData, Split as SplitIxAccounts,
        SplitInstructionArgs as SplitIxData, Withdraw as WithdrawIxAccounts,
        WithdrawInstructionArgs as WithdrawIxData,
    },
    ID,
};

/// StakeProgram Instructions
#[derive(Debug)]
pub enum StakeProgramProgramIx {
    Initialize(InitializeIxAccounts, InitializeIxData),
    Authorize(AuthorizeIxAccounts, AuthorizeIxData),
    DelegateStake(DelegateStakeIxAccounts),
    Split(SplitIxAccounts, SplitIxData),
    Withdraw(WithdrawIxAccounts, WithdrawIxData),
    Deactivate(DeactivateIxAccounts),
    SetLockup(SetLockupIxAccounts, SetLockupIxData),
    Merge(MergeIxAccounts),
    AuthorizeWithSeed(AuthorizeWithSeedIxAccounts, AuthorizeWithSeedIxData),
    InitializeChecked(InitializeCheckedIxAccounts),
    AuthorizeChecked(AuthorizeCheckedIxAccounts, AuthorizeCheckedIxData),
    AuthorizeCheckedWithSeed(
        AuthorizeCheckedWithSeedIxAccounts,
        AuthorizeCheckedWithSeedIxData,
    ),
    SetLockupChecked(SetLockupCheckedIxAccounts, SetLockupCheckedIxData),
    GetMinimumDelegation(GetMinimumDelegationIxAccounts),
    DeactivateDelinquent(DeactivateDelinquentIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = StakeProgramProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "StakeProgram::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<StakeProgramProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = InitializeIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    rent: ix.accounts[1].0.into(),
                };
                let de_ix_data: InitializeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::Initialize(ix_accounts, de_ix_data))
            },
            [173, 193, 102, 210, 219, 137, 113, 120] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = AuthorizeIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    clock: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: AuthorizeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::Authorize(ix_accounts, de_ix_data))
            },
            [50, 110, 95, 179, 194, 75, 140, 246] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = DelegateStakeIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    vote: ix.accounts[1].0.into(),
                    clock: ix.accounts[2].0.into(),
                    stake_history: ix.accounts[3].0.into(),
                    stake_config: ix.accounts[4].0.into(),
                    stake_authority: ix.accounts[5].0.into(),
                };
                Ok(StakeProgramProgramIx::DelegateStake(ix_accounts))
            },
            [124, 189, 27, 43, 216, 40, 147, 66] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = SplitIxAccounts {
                    from: ix.accounts[0].0.into(),
                    to: ix.accounts[1].0.into(),
                    stake_authority: ix.accounts[2].0.into(),
                };
                let de_ix_data: SplitIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::Split(ix_accounts, de_ix_data))
            },
            [183, 18, 70, 156, 148, 109, 161, 34] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = WithdrawIxAccounts {
                    from: ix.accounts[0].0.into(),
                    to: ix.accounts[1].0.into(),
                    clock: ix.accounts[2].0.into(),
                    stake_history: ix.accounts[3].0.into(),
                    withdraw_authority: ix.accounts[4].0.into(),
                };
                let de_ix_data: WithdrawIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::Withdraw(ix_accounts, de_ix_data))
            },
            [44, 112, 33, 172, 113, 28, 142, 13] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = DeactivateIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    clock: ix.accounts[1].0.into(),
                    stake_authority: ix.accounts[2].0.into(),
                };
                Ok(StakeProgramProgramIx::Deactivate(ix_accounts))
            },
            [44, 170, 189, 40, 128, 123, 252, 201] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetLockupIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: SetLockupIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::SetLockup(ix_accounts, de_ix_data))
            },
            [148, 141, 236, 47, 174, 126, 69, 111] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = MergeIxAccounts {
                    to: ix.accounts[0].0.into(),
                    from: ix.accounts[1].0.into(),
                    clock: ix.accounts[2].0.into(),
                    stake_history: ix.accounts[3].0.into(),
                    stake_authority: ix.accounts[4].0.into(),
                };
                Ok(StakeProgramProgramIx::Merge(ix_accounts))
            },
            [7, 18, 211, 41, 76, 83, 115, 61] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = AuthorizeWithSeedIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    authority_base: ix.accounts[1].0.into(),
                    clock: ix.accounts[2].0.into(),
                };
                let de_ix_data: AuthorizeWithSeedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::AuthorizeWithSeed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [219, 90, 58, 161, 139, 88, 246, 28] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = InitializeCheckedIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    rent: ix.accounts[1].0.into(),
                    stake_authority: ix.accounts[2].0.into(),
                    withdraw_authority: ix.accounts[3].0.into(),
                };
                Ok(StakeProgramProgramIx::InitializeChecked(ix_accounts))
            },
            [147, 97, 67, 26, 230, 107, 45, 242] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = AuthorizeCheckedIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    clock: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                    new_authority: ix.accounts[3].0.into(),
                };
                let de_ix_data: AuthorizeCheckedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::AuthorizeChecked(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [14, 230, 154, 165, 225, 209, 194, 210] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = AuthorizeCheckedWithSeedIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    authority_base: ix.accounts[1].0.into(),
                    clock: ix.accounts[2].0.into(),
                    new_authority: ix.accounts[3].0.into(),
                };
                let de_ix_data: AuthorizeCheckedWithSeedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::AuthorizeCheckedWithSeed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [22, 158, 12, 183, 118, 94, 156, 255] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetLockupCheckedIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: SetLockupCheckedIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(StakeProgramProgramIx::SetLockupChecked(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [197, 65, 7, 73, 151, 105, 133, 105] => {
                check_min_accounts_req(accounts_len, 0)?;
                let ix_accounts = GetMinimumDelegationIxAccounts {};
                Ok(StakeProgramProgramIx::GetMinimumDelegation(ix_accounts))
            },
            [6, 113, 198, 138, 228, 163, 159, 221] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = DeactivateDelinquentIxAccounts {
                    stake: ix.accounts[0].0.into(),
                    vote: ix.accounts[1].0.into(),
                    reference_vote: ix.accounts[2].0.into(),
                };
                Ok(StakeProgramProgramIx::DeactivateDelinquent(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
