//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        Buy as BuyIxAccounts, BuyInstructionArgs as BuyIxData, ConfigInit as ConfigInitIxAccounts,
        ConfigInitInstructionArgs as ConfigInitIxData, ConfigUpdate as ConfigUpdateIxAccounts,
        ConfigUpdateInstructionArgs as ConfigUpdateIxData, MigrateFunds as MigrateFundsIxAccounts,
        Sell as SellIxAccounts, SellInstructionArgs as SellIxData,
        TokenMint as TokenMintIxAccounts, TokenMintInstructionArgs as TokenMintIxData,
    },
    ID,
};

/// TokenLaunchpad Instructions
#[derive(Debug)]
pub enum TokenLaunchpadProgramIx {
    TokenMint(TokenMintIxAccounts, TokenMintIxData),
    Buy(BuyIxAccounts, BuyIxData),
    Sell(SellIxAccounts, SellIxData),
    MigrateFunds(MigrateFundsIxAccounts),
    ConfigInit(ConfigInitIxAccounts, ConfigInitIxData),
    ConfigUpdate(ConfigUpdateIxAccounts, ConfigUpdateIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = TokenLaunchpadProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "TokenLaunchpad::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<TokenLaunchpadProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [3, 44, 164, 184, 123, 13, 245, 179] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = TokenMintIxAccounts {
                    sender: ix.accounts[0].0.into(),
                    backend_authority: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    mint: ix.accounts[3].0.into(),
                    mint_metadata: ix.accounts[4].0.into(),
                    curve_token_account: ix.accounts[5].0.into(),
                    config_account: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    associated_token_program: ix.accounts[8].0.into(),
                    mpl_token_metadata: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: TokenMintIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::TokenMint(ix_accounts, de_ix_data))
            },
            [102, 6, 61, 18, 1, 218, 235, 234] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = BuyIxAccounts {
                    sender: ix.accounts[0].0.into(),
                    sender_token_account: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    curve_token_account: ix.accounts[3].0.into(),
                    dex_fee: ix.accounts[4].0.into(),
                    helio_fee: ix.accounts[5].0.into(),
                    mint: ix.accounts[6].0.into(),
                    config_account: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: BuyIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::Buy(ix_accounts, de_ix_data))
            },
            [51, 230, 133, 164, 1, 127, 131, 173] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = SellIxAccounts {
                    sender: ix.accounts[0].0.into(),
                    sender_token_account: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    curve_token_account: ix.accounts[3].0.into(),
                    dex_fee: ix.accounts[4].0.into(),
                    helio_fee: ix.accounts[5].0.into(),
                    mint: ix.accounts[6].0.into(),
                    config_account: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: SellIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::Sell(ix_accounts, de_ix_data))
            },
            [42, 229, 10, 231, 189, 62, 193, 174] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = MigrateFundsIxAccounts {
                    backend_authority: ix.accounts[0].0.into(),
                    migration_authority: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    curve_token_account: ix.accounts[3].0.into(),
                    migration_authority_token_account: ix.accounts[4].0.into(),
                    mint: ix.accounts[5].0.into(),
                    dex_fee_account: ix.accounts[6].0.into(),
                    helio_fee_account: ix.accounts[7].0.into(),
                    config_account: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    associated_token_program: ix.accounts[11].0.into(),
                };
                Ok(TokenLaunchpadProgramIx::MigrateFunds(ix_accounts))
            },
            [13, 236, 164, 173, 106, 253, 164, 185] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ConfigInitIxAccounts {
                    config_authority: ix.accounts[0].0.into(),
                    config_account: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: ConfigInitIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::ConfigInit(ix_accounts, de_ix_data))
            },
            [80, 37, 109, 136, 82, 135, 89, 241] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ConfigUpdateIxAccounts {
                    config_authority: ix.accounts[0].0.into(),
                    config_account: ix.accounts[1].0.into(),
                };
                let de_ix_data: ConfigUpdateIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::ConfigUpdate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
