//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CloseDca as CloseDcaIxAccounts, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData, EndAndClose as EndAndCloseIxAccounts,
        FulfillDlmmFill as FulfillDlmmFillIxAccounts,
        FulfillDlmmFillInstructionArgs as FulfillDlmmFillIxData,
        FulfillFlashFill as FulfillFlashFillIxAccounts,
        FulfillFlashFillInstructionArgs as FulfillFlashFillIxData,
        InitiateDlmmFill as InitiateDlmmFillIxAccounts,
        InitiateFlashFill as InitiateFlashFillIxAccounts, OpenDca as OpenDcaIxAccounts,
        OpenDcaInstructionArgs as OpenDcaIxData, OpenDcaV2 as OpenDcaV2IxAccounts,
        OpenDcaV2InstructionArgs as OpenDcaV2IxData, Transfer as TransferIxAccounts,
        Withdraw as WithdrawIxAccounts, WithdrawFees as WithdrawFeesIxAccounts,
        WithdrawFeesInstructionArgs as WithdrawFeesIxData,
        WithdrawInstructionArgs as WithdrawIxData,
    },
    ID,
};

/// Dca Instructions
#[derive(Debug)]
pub enum DcaProgramIx {
    OpenDca(OpenDcaIxAccounts, OpenDcaIxData),
    OpenDcaV2(OpenDcaV2IxAccounts, OpenDcaV2IxData),
    CloseDca(CloseDcaIxAccounts),
    Withdraw(WithdrawIxAccounts, WithdrawIxData),
    Deposit(DepositIxAccounts, DepositIxData),
    WithdrawFees(WithdrawFeesIxAccounts, WithdrawFeesIxData),
    InitiateFlashFill(InitiateFlashFillIxAccounts),
    FulfillFlashFill(FulfillFlashFillIxAccounts, FulfillFlashFillIxData),
    InitiateDlmmFill(InitiateDlmmFillIxAccounts),
    FulfillDlmmFill(FulfillDlmmFillIxAccounts, FulfillDlmmFillIxData),
    Transfer(TransferIxAccounts),
    EndAndClose(EndAndCloseIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = DcaProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Dca::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<DcaProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [36, 65, 185, 54, 1, 210, 100, 163] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = OpenDcaIxAccounts {
                    dca: ix.accounts[0].0.into(),
                    user: ix.accounts[1].0.into(),
                    input_mint: ix.accounts[2].0.into(),
                    output_mint: ix.accounts[3].0.into(),
                    user_ata: ix.accounts[4].0.into(),
                    in_ata: ix.accounts[5].0.into(),
                    out_ata: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                    event_authority: ix.accounts[10].0.into(),
                    program: ix.accounts[11].0.into(),
                };
                let de_ix_data: OpenDcaIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DcaProgramIx::OpenDca(ix_accounts, de_ix_data))
            },
            [142, 119, 43, 109, 162, 52, 11, 177] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = OpenDcaV2IxAccounts {
                    dca: ix.accounts[0].0.into(),
                    user: ix.accounts[1].0.into(),
                    payer: ix.accounts[2].0.into(),
                    input_mint: ix.accounts[3].0.into(),
                    output_mint: ix.accounts[4].0.into(),
                    user_ata: ix.accounts[5].0.into(),
                    in_ata: ix.accounts[6].0.into(),
                    out_ata: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                    token_program: ix.accounts[9].0.into(),
                    associated_token_program: ix.accounts[10].0.into(),
                    event_authority: ix.accounts[11].0.into(),
                    program: ix.accounts[12].0.into(),
                };
                let de_ix_data: OpenDcaV2IxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DcaProgramIx::OpenDcaV2(ix_accounts, de_ix_data))
            },
            [22, 7, 33, 98, 168, 183, 34, 243] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = CloseDcaIxAccounts {
                    user: ix.accounts[0].0.into(),
                    dca: ix.accounts[1].0.into(),
                    input_mint: ix.accounts[2].0.into(),
                    output_mint: ix.accounts[3].0.into(),
                    in_ata: ix.accounts[4].0.into(),
                    out_ata: ix.accounts[5].0.into(),
                    user_in_ata: ix.accounts[6].0.into(),
                    user_out_ata: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                    token_program: ix.accounts[9].0.into(),
                    associated_token_program: ix.accounts[10].0.into(),
                    event_authority: ix.accounts[11].0.into(),
                    program: ix.accounts[12].0.into(),
                };
                Ok(DcaProgramIx::CloseDca(ix_accounts))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = DepositIxAccounts {
                    user: ix.accounts[0].0.into(),
                    dca: ix.accounts[1].0.into(),
                    in_ata: ix.accounts[2].0.into(),
                    user_in_ata: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    event_authority: ix.accounts[5].0.into(),
                    program: ix.accounts[6].0.into(),
                };
                let de_ix_data: DepositIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DcaProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [198, 212, 171, 109, 144, 215, 174, 89] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = WithdrawFeesIxAccounts {
                    admin: ix.accounts[0].0.into(),
                    mint: ix.accounts[1].0.into(),
                    fee_authority: ix.accounts[2].0.into(),
                    program_fee_ata: ix.accounts[3].0.into(),
                    admin_fee_ata: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    associated_token_program: ix.accounts[7].0.into(),
                };
                let de_ix_data: WithdrawFeesIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DcaProgramIx::WithdrawFees(ix_accounts, de_ix_data))
            },
            [143, 205, 3, 191, 162, 215, 245, 49] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = InitiateFlashFillIxAccounts {
                    keeper: ix.accounts[0].0.into(),
                    dca: ix.accounts[1].0.into(),
                    input_mint: ix.accounts[2].0.into(),
                    keeper_in_ata: ix.accounts[3].0.into(),
                    in_ata: ix.accounts[4].0.into(),
                    out_ata: ix.accounts[5].0.into(),
                    instructions_sysvar: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                };
                Ok(DcaProgramIx::InitiateFlashFill(ix_accounts))
            },
            [115, 64, 226, 78, 33, 211, 105, 162] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = FulfillFlashFillIxAccounts {
                    keeper: ix.accounts[0].0.into(),
                    dca: ix.accounts[1].0.into(),
                    input_mint: ix.accounts[2].0.into(),
                    output_mint: ix.accounts[3].0.into(),
                    keeper_in_ata: ix.accounts[4].0.into(),
                    in_ata: ix.accounts[5].0.into(),
                    out_ata: ix.accounts[6].0.into(),
                    fee_authority: ix.accounts[7].0.into(),
                    fee_ata: ix.accounts[8].0.into(),
                    instructions_sysvar: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    associated_token_program: ix.accounts[12].0.into(),
                    event_authority: ix.accounts[13].0.into(),
                    program: ix.accounts[14].0.into(),
                };
                let de_ix_data: FulfillFlashFillIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DcaProgramIx::FulfillFlashFill(ix_accounts, de_ix_data))
            },
            [155, 193, 80, 121, 91, 147, 254, 187] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = InitiateDlmmFillIxAccounts {
                    keeper: ix.accounts[0].0.into(),
                    dca: ix.accounts[1].0.into(),
                    input_mint: ix.accounts[2].0.into(),
                    keeper_in_ata: ix.accounts[3].0.into(),
                    in_ata: ix.accounts[4].0.into(),
                    out_ata: ix.accounts[5].0.into(),
                    instructions_sysvar: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                };
                Ok(DcaProgramIx::InitiateDlmmFill(ix_accounts))
            },
            [1, 230, 118, 251, 45, 177, 101, 187] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = FulfillDlmmFillIxAccounts {
                    keeper: ix.accounts[0].0.into(),
                    dca: ix.accounts[1].0.into(),
                    input_mint: ix.accounts[2].0.into(),
                    output_mint: ix.accounts[3].0.into(),
                    keeper_in_ata: ix.accounts[4].0.into(),
                    in_ata: ix.accounts[5].0.into(),
                    out_ata: ix.accounts[6].0.into(),
                    fee_authority: ix.accounts[7].0.into(),
                    fee_ata: ix.accounts[8].0.into(),
                    instructions_sysvar: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    token_program: ix.accounts[11].0.into(),
                    associated_token_program: ix.accounts[12].0.into(),
                    event_authority: ix.accounts[13].0.into(),
                    program: ix.accounts[14].0.into(),
                };
                let de_ix_data: FulfillDlmmFillIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(DcaProgramIx::FulfillDlmmFill(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
