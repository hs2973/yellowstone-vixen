//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        ApproveCollectionAuthority as ApproveCollectionAuthorityIxAccounts,
        ApproveUseAuthority as ApproveUseAuthorityIxAccounts,
        ApproveUseAuthorityInstructionArgs as ApproveUseAuthorityIxData,
        BubblegumSetCollectionSize as BubblegumSetCollectionSizeIxAccounts,
        BubblegumSetCollectionSizeInstructionArgs as BubblegumSetCollectionSizeIxData,
        Burn as BurnIxAccounts, BurnEditionNft as BurnEditionNftIxAccounts,
        BurnInstructionArgs as BurnIxData, BurnNft as BurnNftIxAccounts,
        CloseAccounts as CloseAccountsIxAccounts,
        CloseEscrowAccount as CloseEscrowAccountIxAccounts, Collect as CollectIxAccounts,
        ConvertMasterEditionV1ToV2 as ConvertMasterEditionV1ToV2IxAccounts,
        Create as CreateIxAccounts, CreateEscrowAccount as CreateEscrowAccountIxAccounts,
        CreateInstructionArgs as CreateIxData,
        CreateMasterEdition as CreateMasterEditionIxAccounts,
        CreateMasterEditionV3 as CreateMasterEditionV3IxAccounts,
        CreateMasterEditionV3InstructionArgs as CreateMasterEditionV3IxData,
        CreateMetadataAccount as CreateMetadataAccountIxAccounts,
        CreateMetadataAccountV2 as CreateMetadataAccountV2IxAccounts,
        CreateMetadataAccountV3 as CreateMetadataAccountV3IxAccounts,
        CreateMetadataAccountV3InstructionArgs as CreateMetadataAccountV3IxData,
        Delegate as DelegateIxAccounts, DelegateInstructionArgs as DelegateIxData,
        DeprecatedCreateMasterEdition as DeprecatedCreateMasterEditionIxAccounts,
        DeprecatedCreateReservationList as DeprecatedCreateReservationListIxAccounts,
        DeprecatedMintNewEditionFromMasterEditionViaPrintingToken as DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenIxAccounts,
        DeprecatedMintPrintingTokens as DeprecatedMintPrintingTokensIxAccounts,
        DeprecatedMintPrintingTokensViaToken as DeprecatedMintPrintingTokensViaTokenIxAccounts,
        DeprecatedSetReservationList as DeprecatedSetReservationListIxAccounts,
        FreezeDelegatedAccount as FreezeDelegatedAccountIxAccounts, Lock as LockIxAccounts,
        LockInstructionArgs as LockIxData, Migrate as MigrateIxAccounts, Mint as MintIxAccounts,
        MintInstructionArgs as MintIxData,
        MintNewEditionFromMasterEditionViaToken as MintNewEditionFromMasterEditionViaTokenIxAccounts,
        MintNewEditionFromMasterEditionViaTokenInstructionArgs as MintNewEditionFromMasterEditionViaTokenIxData,
        MintNewEditionFromMasterEditionViaVaultProxy as MintNewEditionFromMasterEditionViaVaultProxyIxAccounts,
        MintNewEditionFromMasterEditionViaVaultProxyInstructionArgs as MintNewEditionFromMasterEditionViaVaultProxyIxData,
        Print as PrintIxAccounts, PrintInstructionArgs as PrintIxData,
        PuffMetadata as PuffMetadataIxAccounts,
        RemoveCreatorVerification as RemoveCreatorVerificationIxAccounts,
        Resize as ResizeIxAccounts, Revoke as RevokeIxAccounts,
        RevokeCollectionAuthority as RevokeCollectionAuthorityIxAccounts,
        RevokeInstructionArgs as RevokeIxData, RevokeUseAuthority as RevokeUseAuthorityIxAccounts,
        SetAndVerifyCollection as SetAndVerifyCollectionIxAccounts,
        SetAndVerifySizedCollectionItem as SetAndVerifySizedCollectionItemIxAccounts,
        SetCollectionSize as SetCollectionSizeIxAccounts,
        SetCollectionSizeInstructionArgs as SetCollectionSizeIxData,
        SetTokenStandard as SetTokenStandardIxAccounts, SignMetadata as SignMetadataIxAccounts,
        ThawDelegatedAccount as ThawDelegatedAccountIxAccounts, Transfer as TransferIxAccounts,
        TransferInstructionArgs as TransferIxData,
        TransferOutOfEscrow as TransferOutOfEscrowIxAccounts,
        TransferOutOfEscrowInstructionArgs as TransferOutOfEscrowIxData,
        Unlock as UnlockIxAccounts, UnlockInstructionArgs as UnlockIxData,
        Unverify as UnverifyIxAccounts, UnverifyCollection as UnverifyCollectionIxAccounts,
        UnverifyInstructionArgs as UnverifyIxData,
        UnverifySizedCollectionItem as UnverifySizedCollectionItemIxAccounts,
        Update as UpdateIxAccounts, UpdateInstructionArgs as UpdateIxData,
        UpdateMetadataAccount as UpdateMetadataAccountIxAccounts,
        UpdateMetadataAccountV2 as UpdateMetadataAccountV2IxAccounts,
        UpdateMetadataAccountV2InstructionArgs as UpdateMetadataAccountV2IxData,
        UpdatePrimarySaleHappenedViaToken as UpdatePrimarySaleHappenedViaTokenIxAccounts,
        Use as UseIxAccounts, UseInstructionArgs as UseIxData, Utilize as UtilizeIxAccounts,
        UtilizeInstructionArgs as UtilizeIxData, Verify as VerifyIxAccounts,
        VerifyCollection as VerifyCollectionIxAccounts, VerifyInstructionArgs as VerifyIxData,
        VerifySizedCollectionItem as VerifySizedCollectionItemIxAccounts,
    },
    ID,
};

/// TokenMetadata Instructions
#[derive(Debug)]
pub enum TokenMetadataProgramIx {
    CreateMetadataAccount(CreateMetadataAccountIxAccounts),
    UpdateMetadataAccount(UpdateMetadataAccountIxAccounts),
    DeprecatedCreateMasterEdition(DeprecatedCreateMasterEditionIxAccounts),
    DeprecatedMintNewEditionFromMasterEditionViaPrintingToken(
        DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenIxAccounts,
    ),
    UpdatePrimarySaleHappenedViaToken(UpdatePrimarySaleHappenedViaTokenIxAccounts),
    DeprecatedSetReservationList(DeprecatedSetReservationListIxAccounts),
    DeprecatedCreateReservationList(DeprecatedCreateReservationListIxAccounts),
    SignMetadata(SignMetadataIxAccounts),
    DeprecatedMintPrintingTokensViaToken(DeprecatedMintPrintingTokensViaTokenIxAccounts),
    DeprecatedMintPrintingTokens(DeprecatedMintPrintingTokensIxAccounts),
    CreateMasterEdition(CreateMasterEditionIxAccounts),
    MintNewEditionFromMasterEditionViaToken(
        MintNewEditionFromMasterEditionViaTokenIxAccounts,
        MintNewEditionFromMasterEditionViaTokenIxData,
    ),
    ConvertMasterEditionV1ToV2(ConvertMasterEditionV1ToV2IxAccounts),
    MintNewEditionFromMasterEditionViaVaultProxy(
        MintNewEditionFromMasterEditionViaVaultProxyIxAccounts,
        MintNewEditionFromMasterEditionViaVaultProxyIxData,
    ),
    PuffMetadata(PuffMetadataIxAccounts),
    UpdateMetadataAccountV2(
        UpdateMetadataAccountV2IxAccounts,
        UpdateMetadataAccountV2IxData,
    ),
    CreateMetadataAccountV2(CreateMetadataAccountV2IxAccounts),
    CreateMasterEditionV3(CreateMasterEditionV3IxAccounts, CreateMasterEditionV3IxData),
    VerifyCollection(VerifyCollectionIxAccounts),
    Utilize(UtilizeIxAccounts, UtilizeIxData),
    ApproveUseAuthority(ApproveUseAuthorityIxAccounts, ApproveUseAuthorityIxData),
    RevokeUseAuthority(RevokeUseAuthorityIxAccounts),
    UnverifyCollection(UnverifyCollectionIxAccounts),
    ApproveCollectionAuthority(ApproveCollectionAuthorityIxAccounts),
    RevokeCollectionAuthority(RevokeCollectionAuthorityIxAccounts),
    SetAndVerifyCollection(SetAndVerifyCollectionIxAccounts),
    FreezeDelegatedAccount(FreezeDelegatedAccountIxAccounts),
    ThawDelegatedAccount(ThawDelegatedAccountIxAccounts),
    RemoveCreatorVerification(RemoveCreatorVerificationIxAccounts),
    BurnNft(BurnNftIxAccounts),
    VerifySizedCollectionItem(VerifySizedCollectionItemIxAccounts),
    UnverifySizedCollectionItem(UnverifySizedCollectionItemIxAccounts),
    SetAndVerifySizedCollectionItem(SetAndVerifySizedCollectionItemIxAccounts),
    CreateMetadataAccountV3(
        CreateMetadataAccountV3IxAccounts,
        CreateMetadataAccountV3IxData,
    ),
    SetCollectionSize(SetCollectionSizeIxAccounts, SetCollectionSizeIxData),
    SetTokenStandard(SetTokenStandardIxAccounts),
    BubblegumSetCollectionSize(
        BubblegumSetCollectionSizeIxAccounts,
        BubblegumSetCollectionSizeIxData,
    ),
    BurnEditionNft(BurnEditionNftIxAccounts),
    CreateEscrowAccount(CreateEscrowAccountIxAccounts),
    CloseEscrowAccount(CloseEscrowAccountIxAccounts),
    TransferOutOfEscrow(TransferOutOfEscrowIxAccounts, TransferOutOfEscrowIxData),
    Burn(BurnIxAccounts, BurnIxData),
    Create(CreateIxAccounts, CreateIxData),
    Mint(MintIxAccounts, MintIxData),
    Delegate(DelegateIxAccounts, DelegateIxData),
    Revoke(RevokeIxAccounts, RevokeIxData),
    Lock(LockIxAccounts, LockIxData),
    Unlock(UnlockIxAccounts, UnlockIxData),
    Migrate(MigrateIxAccounts),
    Transfer(TransferIxAccounts, TransferIxData),
    Update(UpdateIxAccounts, UpdateIxData),
    Use(UseIxAccounts, UseIxData),
    Verify(VerifyIxAccounts, VerifyIxData),
    Unverify(UnverifyIxAccounts, UnverifyIxData),
    Collect(CollectIxAccounts),
    Print(PrintIxAccounts, PrintIxData),
    Resize(ResizeIxAccounts),
    CloseAccounts(CloseAccountsIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = TokenMetadataProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "TokenMetadata::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<TokenMetadataProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 1] = ix.data[0..1].try_into()?;
        let mut ix_data = &ix.data[1..];
        match ix_discriminator {
            [0] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CreateMetadataAccountIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    mint: ix.accounts[1].0.into(),
                    mint_authority: ix.accounts[2].0.into(),
                    payer: ix.accounts[3].0.into(),
                    update_authority: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                    rent: ix.accounts[6].0.into(),
                };
                Ok(TokenMetadataProgramIx::CreateMetadataAccount(ix_accounts))
            },
            [1] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateMetadataAccountIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    update_authority: ix.accounts[1].0.into(),
                };
                Ok(TokenMetadataProgramIx::UpdateMetadataAccount(ix_accounts))
            },
            [2] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = DeprecatedCreateMasterEditionIxAccounts {
                    edition: ix.accounts[0].0.into(),
                    mint: ix.accounts[1].0.into(),
                    printing_mint: ix.accounts[2].0.into(),
                    one_time_printing_authorization_mint: ix.accounts[3].0.into(),
                    update_authority: ix.accounts[4].0.into(),
                    printing_mint_authority: ix.accounts[5].0.into(),
                    mint_authority: ix.accounts[6].0.into(),
                    metadata: ix.accounts[7].0.into(),
                    payer: ix.accounts[8].0.into(),
                    token_program: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    rent: ix.accounts[11].0.into(),
                    one_time_printing_authorization_mint_authority: ix.accounts[12].0.into(),
                };
                Ok(TokenMetadataProgramIx::DeprecatedCreateMasterEdition(
                    ix_accounts,
                ))
            },
            [4] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdatePrimarySaleHappenedViaTokenIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    token: ix.accounts[2].0.into(),
                };
                Ok(TokenMetadataProgramIx::UpdatePrimarySaleHappenedViaToken(
                    ix_accounts,
                ))
            },
            [5] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = DeprecatedSetReservationListIxAccounts {
                    master_edition: ix.accounts[0].0.into(),
                    reservation_list: ix.accounts[1].0.into(),
                    resource: ix.accounts[2].0.into(),
                };
                Ok(TokenMetadataProgramIx::DeprecatedSetReservationList(
                    ix_accounts,
                ))
            },
            [6] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = DeprecatedCreateReservationListIxAccounts {
                    reservation_list: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    update_authority: ix.accounts[2].0.into(),
                    master_edition: ix.accounts[3].0.into(),
                    resource: ix.accounts[4].0.into(),
                    metadata: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    rent: ix.accounts[7].0.into(),
                };
                Ok(TokenMetadataProgramIx::DeprecatedCreateReservationList(
                    ix_accounts,
                ))
            },
            [7] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SignMetadataIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    creator: ix.accounts[1].0.into(),
                };
                Ok(TokenMetadataProgramIx::SignMetadata(ix_accounts))
            },
            [8] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = DeprecatedMintPrintingTokensViaTokenIxAccounts {
                    destination: ix.accounts[0].0.into(),
                    token: ix.accounts[1].0.into(),
                    one_time_printing_authorization_mint: ix.accounts[2].0.into(),
                    printing_mint: ix.accounts[3].0.into(),
                    burn_authority: ix.accounts[4].0.into(),
                    metadata: ix.accounts[5].0.into(),
                    master_edition: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    rent: ix.accounts[8].0.into(),
                };
                Ok(TokenMetadataProgramIx::DeprecatedMintPrintingTokensViaToken(ix_accounts))
            },
            [9] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = DeprecatedMintPrintingTokensIxAccounts {
                    destination: ix.accounts[0].0.into(),
                    printing_mint: ix.accounts[1].0.into(),
                    update_authority: ix.accounts[2].0.into(),
                    metadata: ix.accounts[3].0.into(),
                    master_edition: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    rent: ix.accounts[6].0.into(),
                };
                Ok(TokenMetadataProgramIx::DeprecatedMintPrintingTokens(
                    ix_accounts,
                ))
            },
            [10] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CreateMasterEditionIxAccounts {
                    edition: ix.accounts[0].0.into(),
                    mint: ix.accounts[1].0.into(),
                    update_authority: ix.accounts[2].0.into(),
                    mint_authority: ix.accounts[3].0.into(),
                    payer: ix.accounts[4].0.into(),
                    metadata: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    rent: ix.accounts[8].0.into(),
                };
                Ok(TokenMetadataProgramIx::CreateMasterEdition(ix_accounts))
            },
            [12] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ConvertMasterEditionV1ToV2IxAccounts {
                    master_edition: ix.accounts[0].0.into(),
                    one_time_auth: ix.accounts[1].0.into(),
                    printing_mint: ix.accounts[2].0.into(),
                };
                Ok(TokenMetadataProgramIx::ConvertMasterEditionV1ToV2(
                    ix_accounts,
                ))
            },
            [14] => {
                check_min_accounts_req(accounts_len, 1)?;
                let ix_accounts = PuffMetadataIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                };
                Ok(TokenMetadataProgramIx::PuffMetadata(ix_accounts))
            },
            [15] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateMetadataAccountV2IxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    update_authority: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateMetadataAccountV2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenMetadataProgramIx::UpdateMetadataAccountV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [24] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = RevokeCollectionAuthorityIxAccounts {
                    collection_authority_record: ix.accounts[0].0.into(),
                    delegate_authority: ix.accounts[1].0.into(),
                    revoke_authority: ix.accounts[2].0.into(),
                    metadata: ix.accounts[3].0.into(),
                    mint: ix.accounts[4].0.into(),
                };
                Ok(TokenMetadataProgramIx::RevokeCollectionAuthority(
                    ix_accounts,
                ))
            },
            [26] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = FreezeDelegatedAccountIxAccounts {
                    delegate: ix.accounts[0].0.into(),
                    token_account: ix.accounts[1].0.into(),
                    edition: ix.accounts[2].0.into(),
                    mint: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                };
                Ok(TokenMetadataProgramIx::FreezeDelegatedAccount(ix_accounts))
            },
            [27] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = ThawDelegatedAccountIxAccounts {
                    delegate: ix.accounts[0].0.into(),
                    token_account: ix.accounts[1].0.into(),
                    edition: ix.accounts[2].0.into(),
                    mint: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                };
                Ok(TokenMetadataProgramIx::ThawDelegatedAccount(ix_accounts))
            },
            [28] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = RemoveCreatorVerificationIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    creator: ix.accounts[1].0.into(),
                };
                Ok(TokenMetadataProgramIx::RemoveCreatorVerification(
                    ix_accounts,
                ))
            },
            [37] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = BurnEditionNftIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    owner: ix.accounts[1].0.into(),
                    print_edition_mint: ix.accounts[2].0.into(),
                    master_edition_mint: ix.accounts[3].0.into(),
                    print_edition_token_account: ix.accounts[4].0.into(),
                    master_edition_token_account: ix.accounts[5].0.into(),
                    master_edition_account: ix.accounts[6].0.into(),
                    print_edition_account: ix.accounts[7].0.into(),
                    edition_marker_account: ix.accounts[8].0.into(),
                    spl_token_program: ix.accounts[9].0.into(),
                };
                Ok(TokenMetadataProgramIx::BurnEditionNft(ix_accounts))
            },
            [39] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = CloseEscrowAccountIxAccounts {
                    escrow: ix.accounts[0].0.into(),
                    metadata: ix.accounts[1].0.into(),
                    mint: ix.accounts[2].0.into(),
                    token_account: ix.accounts[3].0.into(),
                    edition: ix.accounts[4].0.into(),
                    payer: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    sysvar_instructions: ix.accounts[7].0.into(),
                };
                Ok(TokenMetadataProgramIx::CloseEscrowAccount(ix_accounts))
            },
            [54] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = CollectIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    recipient: ix.accounts[1].0.into(),
                };
                Ok(TokenMetadataProgramIx::Collect(ix_accounts))
            },
            [57] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CloseAccountsIxAccounts {
                    metadata: ix.accounts[0].0.into(),
                    edition: ix.accounts[1].0.into(),
                    mint: ix.accounts[2].0.into(),
                    authority: ix.accounts[3].0.into(),
                    destination: ix.accounts[4].0.into(),
                };
                Ok(TokenMetadataProgramIx::CloseAccounts(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}
