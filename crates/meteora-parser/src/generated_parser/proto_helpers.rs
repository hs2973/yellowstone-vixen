//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

// #[cfg(feature = "proto")]
pub mod proto_types_parsers {
    use yellowstone_vixen_core::proto_helper_traits;
    proto_helper_traits!();
    use sdk::types::LiquidityParameterByStrategy;

    use crate as sdk;
    use crate::proto_def;
    impl IntoProto<proto_def::LiquidityParameterByStrategy> for LiquidityParameterByStrategy {
        fn into_proto(self) -> proto_def::LiquidityParameterByStrategy {
            proto_def::LiquidityParameterByStrategy {
                amount_x: self.amount_x,
                amount_y: self.amount_y,
                active_id: self.active_id,
                max_active_bin_slippage: self.max_active_bin_slippage,
                strategy_parameters: Some(self.strategy_parameters.into_proto()),
            }
        }
    }
    use sdk::types::StrategyParameters;
    impl IntoProto<proto_def::StrategyParameters> for StrategyParameters {
        fn into_proto(self) -> proto_def::StrategyParameters {
            proto_def::StrategyParameters {
                min_bin_id: self.min_bin_id,
                max_bin_id: self.max_bin_id,
                strategy_type: self.strategy_type as i32,
                parameteres: self.parameteres.to_vec(),
            }
        }
    }
    use sdk::types::BinLiquidityDistributionByWeight;
    impl IntoProto<proto_def::BinLiquidityDistributionByWeight> for BinLiquidityDistributionByWeight {
        fn into_proto(self) -> proto_def::BinLiquidityDistributionByWeight {
            proto_def::BinLiquidityDistributionByWeight {
                bin_id: self.bin_id,
                weight: self.weight.into(),
            }
        }
    }
    use sdk::types::CompressedBinDepositAmount;
    impl IntoProto<proto_def::CompressedBinDepositAmount> for CompressedBinDepositAmount {
        fn into_proto(self) -> proto_def::CompressedBinDepositAmount {
            proto_def::CompressedBinDepositAmount {
                bin_id: self.bin_id,
                amount: self.amount,
            }
        }
    }
    use sdk::types::BinLiquidityDistribution;
    impl IntoProto<proto_def::BinLiquidityDistribution> for BinLiquidityDistribution {
        fn into_proto(self) -> proto_def::BinLiquidityDistribution {
            proto_def::BinLiquidityDistribution {
                bin_id: self.bin_id,
                distribution_x: self.distribution_x.into(),
                distribution_y: self.distribution_y.into(),
            }
        }
    }
    use sdk::types::LiquidityParameter;
    impl IntoProto<proto_def::LiquidityParameter> for LiquidityParameter {
        fn into_proto(self) -> proto_def::LiquidityParameter {
            proto_def::LiquidityParameter {
                amount_x: self.amount_x,
                amount_y: self.amount_y,
                bin_liquidity_dist: self
                    .bin_liquidity_dist
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
            }
        }
    }
    use sdk::types::CustomizableParams;
    impl IntoProto<proto_def::CustomizableParams> for CustomizableParams {
        fn into_proto(self) -> proto_def::CustomizableParams {
            proto_def::CustomizableParams {
                active_id: self.active_id,
                bin_step: self.bin_step.into(),
                base_factor: self.base_factor.into(),
                activation_type: self.activation_type.into(),
                has_alpha_vault: self.has_alpha_vault,
                activation_point: self.activation_point,
                creator_pool_on_off_control: self.creator_pool_on_off_control,
                base_fee_power_factor: self.base_fee_power_factor.into(),
                padding: self.padding.to_vec(),
            }
        }
    }
    use sdk::types::CompressedBinDepositAmount2;
    impl IntoProto<proto_def::CompressedBinDepositAmount2> for CompressedBinDepositAmount2 {
        fn into_proto(self) -> proto_def::CompressedBinDepositAmount2 {
            proto_def::CompressedBinDepositAmount2 {
                bin_id: self.bin_id,
                amount: self.amount,
            }
        }
    }
    use sdk::types::BinLiquidityReduction;
    impl IntoProto<proto_def::BinLiquidityReduction> for BinLiquidityReduction {
        fn into_proto(self) -> proto_def::BinLiquidityReduction {
            proto_def::BinLiquidityReduction {
                bin_id: self.bin_id,
                bps_to_remove: self.bps_to_remove.into(),
            }
        }
    }
    use sdk::types::Bin;
    impl IntoProto<proto_def::Bin> for Bin {
        fn into_proto(self) -> proto_def::Bin {
            proto_def::Bin {
                amount_x: self.amount_x,
                amount_y: self.amount_y,
                price: self.price.to_le_bytes().to_vec(),
                liquidity_supply: self.liquidity_supply.to_le_bytes().to_vec(),
                reward_per_token_stored: self
                    .reward_per_token_stored
                    .into_iter()
                    .map(|x| x.to_le_bytes().to_vec())
                    .collect(),
                fee_amount_x_per_token_stored: self
                    .fee_amount_x_per_token_stored
                    .to_le_bytes()
                    .to_vec(),
                fee_amount_y_per_token_stored: self
                    .fee_amount_y_per_token_stored
                    .to_le_bytes()
                    .to_vec(),
                amount_x_in: self.amount_x_in.to_le_bytes().to_vec(),
                amount_y_in: self.amount_y_in.to_le_bytes().to_vec(),
            }
        }
    }
    use sdk::types::ProtocolFee;
    impl IntoProto<proto_def::ProtocolFee> for ProtocolFee {
        fn into_proto(self) -> proto_def::ProtocolFee {
            proto_def::ProtocolFee {
                amount_x: self.amount_x,
                amount_y: self.amount_y,
            }
        }
    }
    use sdk::types::RewardInfo;
    impl IntoProto<proto_def::RewardInfo> for RewardInfo {
        fn into_proto(self) -> proto_def::RewardInfo {
            proto_def::RewardInfo {
                mint: self.mint.to_string(),
                vault: self.vault.to_string(),
                funder: self.funder.to_string(),
                reward_duration: self.reward_duration,
                reward_duration_end: self.reward_duration_end,
                reward_rate: self.reward_rate.to_le_bytes().to_vec(),
                last_update_time: self.last_update_time,
                cumulative_seconds_with_empty_liquidity_reward: self
                    .cumulative_seconds_with_empty_liquidity_reward,
            }
        }
    }
    use sdk::types::Observation;
    impl IntoProto<proto_def::Observation> for Observation {
        fn into_proto(self) -> proto_def::Observation {
            proto_def::Observation {
                cumulative_active_bin_id: self.cumulative_active_bin_id.to_le_bytes().to_vec(),
                created_at: self.created_at,
                last_updated_at: self.last_updated_at,
            }
        }
    }
    use sdk::types::StaticParameters;
    impl IntoProto<proto_def::StaticParameters> for StaticParameters {
        fn into_proto(self) -> proto_def::StaticParameters {
            proto_def::StaticParameters {
                base_factor: self.base_factor.into(),
                filter_period: self.filter_period.into(),
                decay_period: self.decay_period.into(),
                reduction_factor: self.reduction_factor.into(),
                variable_fee_control: self.variable_fee_control,
                max_volatility_accumulator: self.max_volatility_accumulator,
                min_bin_id: self.min_bin_id,
                max_bin_id: self.max_bin_id,
                protocol_share: self.protocol_share.into(),
                base_fee_power_factor: self.base_fee_power_factor.into(),
                padding: self.padding.to_vec(),
            }
        }
    }
    use sdk::types::VariableParameters;
    impl IntoProto<proto_def::VariableParameters> for VariableParameters {
        fn into_proto(self) -> proto_def::VariableParameters {
            proto_def::VariableParameters {
                volatility_accumulator: self.volatility_accumulator,
                volatility_reference: self.volatility_reference,
                index_reference: self.index_reference,
                padding: self.padding.to_vec(),
                last_update_timestamp: self.last_update_timestamp,
                padding1: self.padding1.to_vec(),
            }
        }
    }
    use sdk::types::FeeInfo;
    impl IntoProto<proto_def::FeeInfo> for FeeInfo {
        fn into_proto(self) -> proto_def::FeeInfo {
            proto_def::FeeInfo {
                fee_x_per_token_complete: self.fee_x_per_token_complete.to_le_bytes().to_vec(),
                fee_y_per_token_complete: self.fee_y_per_token_complete.to_le_bytes().to_vec(),
                fee_x_pending: self.fee_x_pending,
                fee_y_pending: self.fee_y_pending,
            }
        }
    }
    use sdk::types::UserRewardInfo;
    impl IntoProto<proto_def::UserRewardInfo> for UserRewardInfo {
        fn into_proto(self) -> proto_def::UserRewardInfo {
            proto_def::UserRewardInfo {
                reward_per_token_completes: self
                    .reward_per_token_completes
                    .into_iter()
                    .map(|x| x.to_le_bytes().to_vec())
                    .collect(),
                reward_pendings: self.reward_pendings.to_vec(),
            }
        }
    }
    use sdk::types::RemainingAccountsSlice;
    impl IntoProto<proto_def::RemainingAccountsSlice> for RemainingAccountsSlice {
        fn into_proto(self) -> proto_def::RemainingAccountsSlice {
            proto_def::RemainingAccountsSlice {
                accounts_type: self.accounts_type as i32,
                length: self.length.into(),
            }
        }
    }
    use sdk::types::RemainingAccountsInfo;
    impl IntoProto<proto_def::RemainingAccountsInfo> for RemainingAccountsInfo {
        fn into_proto(self) -> proto_def::RemainingAccountsInfo {
            proto_def::RemainingAccountsInfo {
                slices: self.slices.into_iter().map(|x| x.into_proto()).collect(),
            }
        }
    }
}
